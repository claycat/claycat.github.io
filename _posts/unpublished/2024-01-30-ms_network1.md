---
title: CS 면접대비 - 네트워크
date: 2024-01-24 12:00:00 +/-TTTT
categories: [Interview]
comments: true
tags:
published: false
---

> **"_OSI 7계층 - 왜 필요한가?_"**
> {: .prompt-tip }

Application - Presentation - Session - Transport - Network - Datalink - Physical  
서로 의존성 없는 레이어 구조를 통해서 더 효율적인 트러블슈팅 및 발전이 가능하기 때문이다.  
관심사의 분리.

> **"_7계층에 대한 간단한 설명?_"**

1. Physical  
   리피터, 케이블, 허브와 같은 데이터를 전송하는 계층

2. DataLink  
   브릿지, 스위치 등 MAC주소를 부여하여 **데이터프레임**에 에러검출, 재전송, 흐름제어
3. Network
   라우터,IP - 라우터를 통해 이동경로를 선택하여 IP 주소를 지정하고 **패킷**을 전달
4. Transport  
   TCP와 UDP 프로토콜을 통해 **세그먼트**를 전달하여 통신을 활성화
5. Session
   API, Socket - TCP/IP 세션의 생성 및 소멸
6. Presentation  
   JPEG, MPEG - 데이터 표현에 대한 동립성 및 암호화
7. Application
   HTTP, FTP, DNS - 응용 프로세스와 직접 관계하여 서비스 수행

<br>

> **"_각 계층에서 사용하는 PDU?_"**
> {: .prompt-tip }

<details>
<summary>펼치기</summary>
<div markdown="1">
 
* Transport Layer : Segment   
* Network Layer: Packet  
* Datalink Layer: Frame

</div>
</details>
<br>

> **"_멀티플렉싱과 디멀티플렉싱은 무엇인가?_"**
> {: .prompt-tip }

L4(Transport 레이어)에서 담당하는 역할이며, 여러개의 소켓에서 내보내는 패킷에 Transport헤더를 추가하여 내보내는것을 Multiplexing이라고 부른다.

반대로, 여러개의 출처에서 받은 패킷들을 분해하여 적절한 소켓으로 분배해준느것을 Demultiplexing이라고 부른다

<br/>

> **"_Stateless VS Connectionless_"**
> {: .prompt-tip }

Stateless하다는것은, 상태를 저장하지 않는다는 의미로, 각 요청이 모두 독립적이며 서로 영향을 주지 않는것이다. REST API가 대표적인 예시로, 서버는 요청에 대한 정보를 저장하지 않는다
Connectionless하다는것은 전용의 커넥션을 수립하지 않고 각 패킷이 서로 독립적이게 전송되는 프로토콜을 의미한다 (UDP)

<br/>

> **"_TCP가 Connection 기반 프로토콜이라면, 웹서버는 요청마다 새로운 소켓을 생성하는가? 그 소켓들의 포트번호는 모두 다른가?_"**  
> {: .prompt-tip }

Yes or no 라면 yes 쪽에 가깝지만, 실상은 복잡하다

> **"_TCP 3-way Handshake 와 4way handshake?_"**

UDP와 다르게 무결성을 보장해야 하는 TCP는 사전의 합의된 연결 과정을 거칩니다.

3-way handshake

1. SYN(seq=x) 을 서버로 전달합니다.
2. 서버는 SYN을 받고 ACK(x+1)와 SYN(seq=y)을 보냅니다.
3. 클라이언트는 마찬가지로 SYN을 받고 ACK(y+1)를 서버로 보냅니다.

4-way handshake

1. FIN 플래그를 서버로 전달합니다
2. 서버는 FIN을 받으면 ACK을 보냅니다.
3. 데이터를 모두 전송했으면, 연결이 끝났다는 FIN을 보냅니다.
4. 클라이언트는 FIN을 받으면 확인했다는 FIN을 보냅니다.
5. 서버 소켓 닫기
6. 클라이언트 소켓 닫기

> **" _Checksum은 무엇인가요?_"**
> {: .prompt-tip }

전달된 네트워크 segment에 에러가 있는지 검출하기 위해서 헤더에 모든 segment content의 값을 더한걸 넣어두는것

<br/>

### 무엇을 더하는건가?

스터디 중 어떤 값을 더하는지에 궁금증이 생겨 알아보았다.
해당 "값"은 체크섬 알고리즘에 따라서 다르다. 몇가지를 소개하자면,

1. CRC  
   내용을 이진수로 취급하여 모두 더해주고, CRC Polynomial이라는 사전에 정해진 값으로 나눈 후, 나머지를 checksum으로 사용한다
2. Summation
   데이터의 각 바이트를 정수형 타입으로 취급하여 모두 더해준다. 만약 16비트를 넘어갈경우, 나머지 연산등을 활용하여 16비트 안쪽으로 만들어준다.

<br/>

> **"_TCP와 UDP 중 어떤 프로토콜이 체크섬을 사용하는가?_"**
> {: .prompt-tip }

둘다 사용한다

> **"_체크섬으로 오류를 복원할 수 있는가?_"**
> {: .prompt-tip }

불가능하다. 오류 검출만 가능하며, checksum으로 파악할 수없는 데이터의 오류 또한 존재할 수 있다.

> **"_주소창에 www.github.com 치면 일어나는 일?_"**
> {: .prompt-tip }

목적은 www.github.com과 "소통"하는 것이다.  
소통하기 위해서는 기본적으로 IP 주소가 필요하다.  
일반적으로는 단순히 DNS에게 물어본다 라고 하고 마무리하겠지만, 조금 더 깊게 들어가보자.

1. 윈도우의 경우, IP주소 획득을 위해 가장 처음 하는 일은 hosts 파일을 확인하는것이다.  
   만약 hosts 파일에 등록된 IP가 있다면 그곳으로 유도된다.

2. 이후에는 DNS Cache를 참조한다.
   여기에는 DNS의 응답이 캐싱되어있다.

3. 공유기가 DNS값으로 설정되어있다면, 공유기를 경유하여 DNS Forwarding 기능을 통해 요청과 응답을 받아서 정확한 주소를 받는다.  
   이때 DNS 캐시는 업데이트된다 (RAM에 저장되어있음)

4. 별도의 공유기 설정이 존재하지 않는다면, 단순히 ISP를 거쳐 DNS를 통해 IP주소를 획득할 것이다.  
   IP 획득을 완료했다면, 해당 호스트에게 TCP 연결을 시도한다 (HTTP요청이라는 전제 하에)
   TCP 연결 과정을 모두 거친 이후에는 연결이 수립되고, DNS에게 질의를 하게 된다.

5. 연결 수립 이후에는 CSS/HTML/JS 파일들을 다운로드하고, 브라우저에서 렌더링하게 된다.

6. HTML/CSS/JS 등은 Disk에 캐싱된다. 이후에 다시 접속할경우, Disk에 저장되어있는 캐시를 참조한다

- DNS의 구조
  - Root DNS가 전세계에 13개 존재하며, 병렬화되어있음

<br/>

## 키

<br/>

> **"_공개키와 대칭키의 차이는? 장단점은?_"**
> {: .prompt-tip }

- 공개키는 암호화하는 키와 복호화하는 키가 동일한것을 의미한다
  - 빠르다
  - 노출될 경우 위험하다
- 대칭키는 암호화하는 키와 복호화하는키가 다른것을 의미한다
  - 나만 보고싶을 경우, 공개키로 암호화하면 개인키로 풀 수 있음
  - 남이 보고싶게 할 경우, 개인키로 암호화하면 공개키로 풀 수 있음

<br/>

> **"_HTTPS는 어떤 종류의 키를 사용하는가?_"**
> {: .prompt-tip }

- 대칭키와 비대칭키 두가지 종류를 모두 사용한다

<br/>

> **"_TLS/SSL Handshake 과정_"**
> {: .prompt-tip }

1. TCP 연결을 설정
2. 클라이언트는 서버측으로 HelloClient 메시지를 보냄
3. 서버는 HelloClient에 대한 응답으로 HelloServer 메시지와 함께 인증서를 전송
4. 클라이언트는 인증서의 유효성을 확인
5. 클라이언트는 자신이 생성한 랜덤 대칭키를 인증서에서 찾을 수 있는 서버의 공개키를 이용해 암호화하여 서버에 전송
6. 서버는 자신의 개인키를 이용해 대칭키를 확보하고, 메시지를 해석

<br/>

## 어떻게 CA 인증서가 유효한지 확인할 수 있을까?

### 1. 브라우저에 사전 설치되어있는 인증된 공급자일경우

브라우저에 여러개의 자격이 증명된 SSL인증서의 리스트가 설치되어 있다.
해당 SSL인증서는 인증된 단체(Symantec, Comodo 등)에 의해서 관리되고 있다.
만약 서버가 해당 단체에서 발급된 인증서라는것을 확인하면 인증이 완료된다

### 2. 인증된 공급자가 신뢰한다고 보장하는 인증서일 경우

모든 요청들이 인증된 단체에서 발생할 수는 없다.  
이럴 경우, 인증된 공급자가 해당 인증서가 유효하다고 보증해줄 수 있다. 보증하는 방식은 다음과 같다.

1.  CA는 인증서에 hash를 취해 **개인키**로 암호화 하여 **디지털 서명** 을 생성하고, 인증서에 첨부한다
2.  클라이언트는 디지털 서명을 CA의 **공개키**로 복호화한값과 직접 인증서에 hash를 취한 값과 비교하여 인증서의 유효성을 검사한다

<br/>

### 전송자를 검증하는게 아니라, 공개키를 검증하는것이다

클라이언트는 사실 인증서를 보낸곳을 검증하는것이 아니라, 인증서에 담겨있는 **공개키**가 안전한지 검증한다.  
SSL인증서는 공개적으로 오픈되어있으며 얼마든지 조작될 수 있기 때문에, 실제로 공격자는 인증서를 위조하여 얼마든지 속일 수 있다.  
예를 들어 공격자는 마이크로소프트의 SSL인증서를 자신의 요청에 끼워넣어 위장할 수 있다.  
HTTPS가 안전한 이유는, 마이크로소프트의 SSL인증서로 위장을 하더라도, 우리는 마이크로소프트의 공개키를 사용해 내용을 암호화하였기 때문에  
공격자는 마이크로소프트의 개인키를 보유하고있지 않은 이상 내용물을 탈취할 수 없는 것이다.

출처 : https://robertheaton.com/2014/03/27/how-does-https-actually-work/

<br/>

## 로드 밸런서

<br/>

> **"_로드 밸런서란?_"**
> {: .prompt-tip }

서버에 가해지는 부하를 분산시켜주는 장치 또는 기술을 의미한다
일반적으로 접속 요청을 사전에 할당한 Virtual IP로 받아서 분산용 서버들로 보내준다

<br/>

### 헬스체크

분산시켜주는 대상 중 하나가 죽을 경우, 요청이 유실되지 않도록 지속적으로 서버의 상태를 확인할 필요가 있다.

1. ICMP - 직접 ping을 때려 서버의 상태를 확인
2. TCP연결 - L4단계의 요청이기때문에 포트의 상태까지 확인할 수 있다.
3. HTTP요청 - L7단계의 요청이기 때문에 애플리케이션의 상태까지 확인 가능하다

### 부하 분산 알고리즘

1. 가중치 기반 라운드 로빈 - 가중치가 높은 서버에 요청을 배분한다. 처리성능이 각각 다를 경우 사용
2. Least Connection - 연결 갯수가 가장 적은 서버에 배분한다
3. Hash - IP 주소를 특정 서버로 매핑하여 처리 - 특정 사용자가 항상 동일한 서버에 연결되어야 할 경우

<br/>

## Direct Server Return

로드 밸런서를 거치지 않고 직접 서버에서 클라이언트로 응답하는것
{: .prompt-tip }
왜 ? 로드 밸런서가 있어야 부하분산을 하는것이 아닌가?

동영상 스트리밍 서비스처럼 들어오는 트래픽보다 나가는 트래픽이 훨씬 큰 경우에는 응답 요청들이 모두 로드 밸런서를 거쳐야 하기 때문에 로드 밸런서가 병목지점이 될 수 있다.
