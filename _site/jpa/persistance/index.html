<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>영속성 핥아보기 : Claycat</title>
<meta name="description" content="영속성이란    영원히 계속되는 성질이나 능력   영속화 : 어플리케이션의 상태와 상관없이 물리적인 저장소에 데이터를 저장하는 행위            데이터를 어떤 공간에 어떤 형태로 저장할 것인가?       RDMBS에 데이터를 저장하는 방법은 SQL이라고 볼 수 있다           자바의 경우    자바 어플리케이션에서는 JDBC 인터페이스를 사용            각 데이터베이스 제조사들은 JDBC 인터페이스를 구현하는 클래스(드라이버) 들을 제공       순수 JDBC를 사용할 경우                    데이터베이스 접속, 질의, 유저 객체로의 변환 절차가 필요           모두 동일한 파일에서 관리해야 한다                            칼럼의 이름명이 변경 등 사소한 테이블의 변경이 sql 문자열에 전파됨                                                   객체와 테이블의 불일치    객체지향 어플리케이션과 RDBMS의 불일치를 맞추는데 많은 리소스 소모   이를 해결해주는것이 Persistence Framework            SQL Mapping (MyBatis - 실제 SQL 코드와 비즈니스 로직의 분리)                    .xml 형태로 외부로 빼내준다                       OR Mapping (객체와 관계형 데이터베이 사이의 매핑, SQL을 생성)           JPA    JPA를 통해 객체를 영속화 하려고 사용하는것이 EntityManager이고, EntityManagerFactory를 통해 얻음   EntityManager는 영속성 컨텍스트를 통해 영속 객체를 관리            영속 객체 = 실제로 데이터가 영속적으로 저장되기 위한 객체                    Customer c = new Customer()가 entityManager를 통해 영속성 컨텍스트에 등록되고 트랜잭션 내에서 관리되다가 끝났을 때 데이터베이스 안으로 등록된다                           사용자는 EntityManager 인스턴스 객체의 메소드를 이용해 영속 객체를 관리   근데 왜 실제로 EntityManager EntityManagerFactory 실제 코드에서는 없음 ?            이런 작업들은 Spring Framework에 위임할 수 있음           영속성 컨텍스트 - INSERT AND SELECT    고유 ID를 갖는 모든 영속 객체 인스턴스에 대한 집합   EntityManagerFactory emf = Persistence.createEntityManagerFactory(); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction();  Customer customer = new Customer(); //아직 일반객체 em.persist(customer); //이제 등록됨 (1차 캐시) 아직 INSERT는 X em.persist(customer); //캐시에 이미 해당 객체 있어서 do nothing  Customer c1 = em.find(Customer.class, &quot;ID0001&quot;); // SELECT X, 1차 캐시에 있는 데이터를 받아온다  tx.commit() //이순간 INSERT 발생      모든건 트랜잭션 안에서 일어난다            transaction 내부에서 persist가 일어나야 1차 캐시에 들어가있는것           괜히 캐시라고 부르는게 아니다            entityManger.find 의 경우, Persistence Context에 있다면 그녀석을 가져오고       만약 없다면 db에 select문을 날려서 가져온다                    select 문을 통해 가져온 객체는 다시 persistence context에 보관된다                           SQL 저장소            persist 메소드가 호출될 경우, SQL 저장소(쓰기 지연)에 SQL 저장됨                    flush / transaction commit 시점에 저장되어있는 SQL들을 실행                           영속성 컨텍스트 - UPDATES    객체의 상태 변경            UPDATE 쿼리들은 마찬가지로 SQL 저장소에 보관 후 커밋 시점에 반영       foundCustomer.setName(&quot;Kim&quot;) 할경우, 현재 객체와 snapshot의 상태와 비교하고,   만약 다를 경우 UPDATE 쿼리를 SQL 저장소에 저장함           Flush    영속성 컨텍스트의 내용을 데이터베이스와 동기화 하는것   flush 방식            EntityManager.flush() 직접 호출       트랜잭션의 커밋       JPQL 쿼리 실행           flush를 실행하더라도 영속성 컨텍스트 내용은 유지됨   flush가 실행되더라도, 데이터베이스 내용이 완전히 변경된것은 아님            transaction이 완성되어서 롤백이 안되는 시점까지 간 것이 아니다       커밋하기 이전, 쿼리가 “반영된 시점”까지를 의미함           tx.begin() try {     Customer customer = new Customer(&quot;ID001&quot;, &quot;KIM&quot;);     em.persist(customer);     // 이 시점에는 우리의 java application에서는 persistence context와 db 동기화     // 하지만 다른 어플리케이션 (h2 console) 에서는 tx.commit()을 하지 않는이상 반영 X      tx.commit();     // 이 시점 이후로는 반영 완료 } catch(Exception e) {     tx.rollaback(); }">



<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="Claycat">
<meta property="og:title" content="영속성 핥아보기">
<meta property="og:url" content="http://localhost:4000/jpa/persistance/">


  <meta property="og:description" content="영속성이란    영원히 계속되는 성질이나 능력   영속화 : 어플리케이션의 상태와 상관없이 물리적인 저장소에 데이터를 저장하는 행위            데이터를 어떤 공간에 어떤 형태로 저장할 것인가?       RDMBS에 데이터를 저장하는 방법은 SQL이라고 볼 수 있다           자바의 경우    자바 어플리케이션에서는 JDBC 인터페이스를 사용            각 데이터베이스 제조사들은 JDBC 인터페이스를 구현하는 클래스(드라이버) 들을 제공       순수 JDBC를 사용할 경우                    데이터베이스 접속, 질의, 유저 객체로의 변환 절차가 필요           모두 동일한 파일에서 관리해야 한다                            칼럼의 이름명이 변경 등 사소한 테이블의 변경이 sql 문자열에 전파됨                                                   객체와 테이블의 불일치    객체지향 어플리케이션과 RDBMS의 불일치를 맞추는데 많은 리소스 소모   이를 해결해주는것이 Persistence Framework            SQL Mapping (MyBatis - 실제 SQL 코드와 비즈니스 로직의 분리)                    .xml 형태로 외부로 빼내준다                       OR Mapping (객체와 관계형 데이터베이 사이의 매핑, SQL을 생성)           JPA    JPA를 통해 객체를 영속화 하려고 사용하는것이 EntityManager이고, EntityManagerFactory를 통해 얻음   EntityManager는 영속성 컨텍스트를 통해 영속 객체를 관리            영속 객체 = 실제로 데이터가 영속적으로 저장되기 위한 객체                    Customer c = new Customer()가 entityManager를 통해 영속성 컨텍스트에 등록되고 트랜잭션 내에서 관리되다가 끝났을 때 데이터베이스 안으로 등록된다                           사용자는 EntityManager 인스턴스 객체의 메소드를 이용해 영속 객체를 관리   근데 왜 실제로 EntityManager EntityManagerFactory 실제 코드에서는 없음 ?            이런 작업들은 Spring Framework에 위임할 수 있음           영속성 컨텍스트 - INSERT AND SELECT    고유 ID를 갖는 모든 영속 객체 인스턴스에 대한 집합   EntityManagerFactory emf = Persistence.createEntityManagerFactory(); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction();  Customer customer = new Customer(); //아직 일반객체 em.persist(customer); //이제 등록됨 (1차 캐시) 아직 INSERT는 X em.persist(customer); //캐시에 이미 해당 객체 있어서 do nothing  Customer c1 = em.find(Customer.class, &quot;ID0001&quot;); // SELECT X, 1차 캐시에 있는 데이터를 받아온다  tx.commit() //이순간 INSERT 발생      모든건 트랜잭션 안에서 일어난다            transaction 내부에서 persist가 일어나야 1차 캐시에 들어가있는것           괜히 캐시라고 부르는게 아니다            entityManger.find 의 경우, Persistence Context에 있다면 그녀석을 가져오고       만약 없다면 db에 select문을 날려서 가져온다                    select 문을 통해 가져온 객체는 다시 persistence context에 보관된다                           SQL 저장소            persist 메소드가 호출될 경우, SQL 저장소(쓰기 지연)에 SQL 저장됨                    flush / transaction commit 시점에 저장되어있는 SQL들을 실행                           영속성 컨텍스트 - UPDATES    객체의 상태 변경            UPDATE 쿼리들은 마찬가지로 SQL 저장소에 보관 후 커밋 시점에 반영       foundCustomer.setName(&quot;Kim&quot;) 할경우, 현재 객체와 snapshot의 상태와 비교하고,   만약 다를 경우 UPDATE 쿼리를 SQL 저장소에 저장함           Flush    영속성 컨텍스트의 내용을 데이터베이스와 동기화 하는것   flush 방식            EntityManager.flush() 직접 호출       트랜잭션의 커밋       JPQL 쿼리 실행           flush를 실행하더라도 영속성 컨텍스트 내용은 유지됨   flush가 실행되더라도, 데이터베이스 내용이 완전히 변경된것은 아님            transaction이 완성되어서 롤백이 안되는 시점까지 간 것이 아니다       커밋하기 이전, 쿼리가 “반영된 시점”까지를 의미함           tx.begin() try {     Customer customer = new Customer(&quot;ID001&quot;, &quot;KIM&quot;);     em.persist(customer);     // 이 시점에는 우리의 java application에서는 persistence context와 db 동기화     // 하지만 다른 어플리케이션 (h2 console) 에서는 tx.commit()을 하지 않는이상 반영 X      tx.commit();     // 이 시점 이후로는 반영 완료 } catch(Exception e) {     tx.rollaback(); }">







  <meta property="article:published_time" content="2024-01-24T12:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/jpa/persistance/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Claycat",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Claycat Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->



<link
  rel="apple-touch-icon"
  sizes="180x180"
  href="/assets/images/favicons/apple-touch-icon.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="32x32"
  href="/assets/images/favicons/favicon-32x32.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="16x16"
  href="/assets/images/favicons/favicon-16x16.png"
/>

<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico" />
<meta name="apple-mobile-web-app-title" content="Claycat" />
<meta name="application-name" content="Claycat" />
<meta name="msapplication-TileColor" content="#da532c" />
<meta
  name="msapplication-config"
  content="/assets/images/favicons/browserconfig.xml"
/>
<meta name="theme-color" content="#ffffff" />

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Claycat
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
         

<div id="main" role="main">
  


  <article
    class="page h-entry"
    itemscope
    itemtype="https://schema.org/CreativeWork"
  >
    <meta
      itemprop="headline"
      content="영속성 핥아보기"
    /> <meta
      itemprop="description"
      content="영속성이란  영원히 계속되는 성질이나 능력  영속화 : 어플리케이션의 상태와 상관없이 물리적인 저장소에 데이터를 저장하는 행위          데이터를 어떤 공간에 어떤 형태로 저장할 것인가?      RDMBS에 데이터를 저장하는 방법은 SQL이라고 볼 수 있다      자바의 경우  자바 어플리케이션에서는 JDBC 인터페이스를 사용          각 데이터베이스 제조사들은 JDBC 인터페이스를 구현하는 클래스(드라이버) 들을 제공      순수 JDBC를 사용할 경우                  데이터베이스 접속, 질의, 유저 객체로의 변환 절차가 필요          모두 동일한 파일에서 관리해야 한다                          칼럼의 이름명이 변경 등 사소한 테이블의 변경이 sql 문자열에 전파됨                                          객체와 테이블의 불일치  객체지향 어플리케이션과 RDBMS의 불일치를 맞추는데 많은 리소스 소모  이를 해결해주는것이 Persistence Framework          SQL Mapping (MyBatis - 실제 SQL 코드와 비즈니스 로직의 분리)                  .xml 형태로 외부로 빼내준다                    OR Mapping (객체와 관계형 데이터베이 사이의 매핑, SQL을 생성)      JPA  JPA를 통해 객체를 영속화 하려고 사용하는것이 EntityManager이고, EntityManagerFactory를 통해 얻음  EntityManager는 영속성 컨텍스트를 통해 영속 객체를 관리          영속 객체 = 실제로 데이터가 영속적으로 저장되기 위한 객체                  Customer c = new Customer()가 entityManager를 통해 영속성 컨텍스트에 등록되고트랜잭션 내에서 관리되다가 끝났을 때 데이터베이스 안으로 등록된다                      사용자는 EntityManager 인스턴스 객체의 메소드를 이용해 영속 객체를 관리  근데 왜 실제로 EntityManager EntityManagerFactory 실제 코드에서는 없음 ?          이런 작업들은 Spring Framework에 위임할 수 있음      영속성 컨텍스트 - INSERT AND SELECT  고유 ID를 갖는 모든 영속 객체 인스턴스에 대한 집합EntityManagerFactory emf = Persistence.createEntityManagerFactory();EntityManager em = emf.createEntityManager();EntityTransaction tx = em.getTransaction();Customer customer = new Customer(); //아직 일반객체em.persist(customer); //이제 등록됨 (1차 캐시) 아직 INSERT는 Xem.persist(customer); //캐시에 이미 해당 객체 있어서 do nothingCustomer c1 = em.find(Customer.class, &quot;ID0001&quot;); // SELECT X, 1차 캐시에 있는 데이터를 받아온다tx.commit() //이순간 INSERT 발생   모든건 트랜잭션 안에서 일어난다          transaction 내부에서 persist가 일어나야 1차 캐시에 들어가있는것        괜히 캐시라고 부르는게 아니다          entityManger.find 의 경우, Persistence Context에 있다면 그녀석을 가져오고      만약 없다면 db에 select문을 날려서 가져온다                  select 문을 통해 가져온 객체는 다시 persistence context에 보관된다                      SQL 저장소          persist 메소드가 호출될 경우, SQL 저장소(쓰기 지연)에 SQL 저장됨                  flush / transaction commit 시점에 저장되어있는 SQL들을 실행                    영속성 컨텍스트 - UPDATES  객체의 상태 변경          UPDATE 쿼리들은 마찬가지로 SQL 저장소에 보관 후 커밋 시점에 반영      foundCustomer.setName(&quot;Kim&quot;) 할경우, 현재 객체와 snapshot의 상태와 비교하고,  만약 다를 경우 UPDATE 쿼리를 SQL 저장소에 저장함      Flush  영속성 컨텍스트의 내용을 데이터베이스와 동기화 하는것  flush 방식          EntityManager.flush() 직접 호출      트랜잭션의 커밋      JPQL 쿼리 실행        flush를 실행하더라도 영속성 컨텍스트 내용은 유지됨  flush가 실행되더라도, 데이터베이스 내용이 완전히 변경된것은 아님          transaction이 완성되어서 롤백이 안되는 시점까지 간 것이 아니다      커밋하기 이전, 쿼리가 “반영된 시점”까지를 의미함      tx.begin()try {    Customer customer = new Customer(&quot;ID001&quot;, &quot;KIM&quot;);    em.persist(customer);    // 이 시점에는 우리의 java application에서는 persistence context와 db 동기화    // 하지만 다른 어플리케이션 (h2 console) 에서는 tx.commit()을 하지 않는이상 반영 X    tx.commit();    // 이 시점 이후로는 반영 완료} catch(Exception e) {    tx.rollaback();}"
    /> <meta
      itemprop="datePublished"
      content="2024-01-24T12:00:00+09:00"
    /> 

    <div class="page__inner-wrap">
      
      <header>
        
        <h1 id="page-title" class="page__title" itemprop="headline">
          <p>영속성 핥아보기</p>

        </h1>
         
      </header>
      

      <section class="page__content e-content" itemprop="text">
         <h1 id="영속성이란">영속성이란</h1>
<ul>
  <li>영원히 계속되는 성질이나 능력</li>
  <li>영속화 : 어플리케이션의 상태와 상관없이 물리적인 저장소에 데이터를 저장하는 행위
    <ul>
      <li>데이터를 <strong>어떤</strong> 공간에 <strong>어떤</strong> 형태로 저장할 것인가?</li>
      <li>RDMBS에 데이터를 저장하는 방법은 SQL이라고 볼 수 있다</li>
    </ul>
  </li>
</ul>

<h3 id="자바의-경우">자바의 경우</h3>
<ul>
  <li>자바 어플리케이션에서는 JDBC 인터페이스를 사용
    <ul>
      <li>각 데이터베이스 제조사들은 JDBC 인터페이스를 구현하는 클래스(드라이버) 들을 제공</li>
      <li>순수 JDBC를 사용할 경우
        <ul>
          <li>데이터베이스 접속, 질의, 유저 객체로의 변환 절차가 필요</li>
          <li>모두 동일한 파일에서 관리해야 한다
            <ul>
              <li>칼럼의 이름명이 변경 등 사소한 테이블의 변경이 sql 문자열에 전파됨</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="객체와-테이블의-불일치">객체와 테이블의 불일치</h3>
<ul>
  <li>객체지향 어플리케이션과 RDBMS의 불일치를 맞추는데 많은 리소스 소모</li>
  <li>이를 해결해주는것이 Persistence Framework
    <ul>
      <li>SQL Mapping (MyBatis - 실제 SQL 코드와 비즈니스 로직의 분리)
        <ul>
          <li>.xml 형태로 외부로 빼내준다</li>
        </ul>
      </li>
      <li>OR Mapping (객체와 관계형 데이터베이 사이의 매핑, SQL을 생성)</li>
    </ul>
  </li>
</ul>

<h1 id="jpa">JPA</h1>
<ul>
  <li>JPA를 통해 객체를 영속화 하려고 사용하는것이 EntityManager이고, EntityManagerFactory를 통해 얻음</li>
  <li>EntityManager는 영속성 컨텍스트를 통해 영속 객체를 관리
    <ul>
      <li>영속 객체 = 실제로 데이터가 영속적으로 저장되기 위한 객체
        <ul>
          <li>Customer c = new Customer()가 entityManager를 통해 영속성 컨텍스트에 등록되고<br />
트랜잭션 내에서 관리되다가 끝났을 때 데이터베이스 안으로 등록된다</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>사용자는 EntityManager 인스턴스 객체의 메소드를 이용해 영속 객체를 관리</li>
  <li>근데 왜 실제로 EntityManager EntityManagerFactory 실제 코드에서는 없음 ?
    <ul>
      <li>이런 작업들은 Spring Framework에 위임할 수 있음</li>
    </ul>
  </li>
</ul>

<h2 id="영속성-컨텍스트---insert-and-select">영속성 컨텍스트 - INSERT AND SELECT</h2>
<ul>
  <li>고유 ID를 갖는 모든 영속 객체 인스턴스에 대한 집합</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManagerFactory</span> <span class="n">emf</span> <span class="o">=</span> <span class="nc">Persistence</span><span class="o">.</span><span class="na">createEntityManagerFactory</span><span class="o">();</span>
<span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
<span class="nc">EntityTransaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>

<span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Customer</span><span class="o">();</span> <span class="c1">//아직 일반객체</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">customer</span><span class="o">);</span> <span class="c1">//이제 등록됨 (1차 캐시) 아직 INSERT는 X</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">customer</span><span class="o">);</span> <span class="c1">//캐시에 이미 해당 객체 있어서 do nothing</span>

<span class="nc">Customer</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Customer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"ID0001"</span><span class="o">);</span> <span class="c1">// SELECT X, 1차 캐시에 있는 데이터를 받아온다</span>

<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">()</span> <span class="c1">//이순간 INSERT 발생 </span>
</code></pre></div></div>
<ul>
  <li><strong>모든건 트랜잭션 안에서 일어난다</strong>
    <ul>
      <li>transaction 내부에서 persist가 일어나야 1차 캐시에 들어가있는것</li>
    </ul>
  </li>
  <li><strong>괜히 캐시라고 부르는게 아니다</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">entityManger.find</code> 의 경우, Persistence Context에 있다면 그녀석을 가져오고</li>
      <li>만약 없다면 db에 select문을 날려서 가져온다
        <ul>
          <li><strong>select 문을 통해 가져온 객체는 다시 persistence context에 보관된다</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>SQL 저장소</strong>
    <ul>
      <li>persist 메소드가 호출될 경우, SQL 저장소(쓰기 지연)에 SQL 저장됨
        <ul>
          <li>flush / transaction commit 시점에 저장되어있는 SQL들을 실행</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="영속성-컨텍스트---updates">영속성 컨텍스트 - UPDATES</h2>
<ul>
  <li>객체의 상태 변경
    <ul>
      <li>UPDATE 쿼리들은 마찬가지로 SQL 저장소에 보관 후 커밋 시점에 반영</li>
      <li><code class="language-plaintext highlighter-rouge">foundCustomer.setName("Kim")</code> 할경우, 현재 객체와 snapshot의 상태와 비교하고,<br />
  만약 다를 경우 UPDATE 쿼리를 SQL 저장소에 저장함</li>
    </ul>
  </li>
</ul>

<h2 id="flush">Flush</h2>
<ul>
  <li>영속성 컨텍스트의 내용을 데이터베이스와 동기화 하는것</li>
  <li>flush 방식
    <ul>
      <li><code class="language-plaintext highlighter-rouge">EntityManager.flush()</code> 직접 호출</li>
      <li>트랜잭션의 커밋</li>
      <li>JPQL 쿼리 실행</li>
    </ul>
  </li>
  <li>flush를 실행하더라도 영속성 컨텍스트 내용은 유지됨</li>
  <li>flush가 실행되더라도, 데이터베이스 내용이 완전히 변경된것은 아님
    <ul>
      <li>transaction이 완성되어서 롤백이 안되는 시점까지 간 것이 아니다</li>
      <li>커밋하기 이전, 쿼리가 “반영된 시점”까지를 의미함</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">()</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="s">"ID001"</span><span class="o">,</span> <span class="s">"KIM"</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">customer</span><span class="o">);</span>
    <span class="c1">// 이 시점에는 우리의 java application에서는 persistence context와 db 동기화</span>
    <span class="c1">// 하지만 다른 어플리케이션 (h2 console) 에서는 tx.commit()을 하지 않는이상 반영 X</span>

    <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
    <span class="c1">// 이 시점 이후로는 반영 완료</span>
<span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">rollaback</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
 
      </section>

      <footer class="page__meta">
         


  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 카테고리: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#jpa" class="page__taxonomy-item p-category" rel="tag">JPA</a>
    
    </span>
  </p>

 

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 업데이트:</strong> <time class="dt-published" datetime="2024-01-24T12:00:00+09:00">January 24, 2024</time></p>

      </footer>
      
  <nav class="pagination">
    
      <a href="/interview/ms_os1/" class="pagination--pager" title="CS 면접대비 - 운영체제
">이전</a>
    
    
      <a href="/web_servers/" class="pagination--pager" title="웹 서버와 포트, 소켓, 그리고 스레드
">다음</a>
    
  </nav>

    </div>

    
  </article>

   
  <div class="page__related">
    <h2 class="page__related-title">
      참고
    </h2>
    <div class="grid__wrapper">
       



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/concurrency/" rel="permalink">티케팅 시스템 구현에서의 동시성 문제 : 원인
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> April 02 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">개요
</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/architecture/" rel="permalink">스프링 코드 아키텍처
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> March 25 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">작성자 : Claycat

개요

여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?

이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다.
프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요.
결정 과정에 대해서 소개해...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/isp1/" rel="permalink">인터페이스 분리 원칙에 대해
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">다 알고 있는 사실

  어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다
자신이 사용하는 메서드에만 의존해야 한다


매번 나오는 설명입니다.
보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.

interface Person {
	public void ...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/jpa/persistance2/" rel="permalink">영속성 까보기 (feat. 10분 테코톡)
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">JPA와 영속성

JPA 영속성 관련 실험 중 이상한 케이스를 발견했습니다.
우아한형제들 테코톡의 문제상황 1에서도 비슷한 예제가 있습니다.
영상에서는 정확히 이유를 설명하지는 않고 영속성 설명으로 넘어가버려서
정확한 이유를 정리해보려고 합니다.

@Getter
@Entity
@A...</p>
  </article>
</div>
 
    </div>
  </div>
   
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력하세요..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>팔로우:</strong></li>
    

    
      
        
          <li><a href="https://github.com/claycat" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Claycat. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', 'claycat');
    script.setAttribute('data-repo-id', 'R_kgDOLLYTXw');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOLLYTX84Ccyz5');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>
  





  </body>
</html>
