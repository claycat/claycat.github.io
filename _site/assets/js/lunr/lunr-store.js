var store = [{
        "title": "CS 면접대비 - 데이터베이스",
        "excerpt":"데이터베이스 키에 대해서 설명해주세요            Candidate Key                    Unique 식별           최소 속성                       Foreign Key                    다른 테이블의 Primary Key                       Primary Key                    Candidate Key중 선택된 Main Key                       Alternate Key                    Candidate Key - Primary Key                       Super Key                    Unique 식별하지만 최소 속성은 만족 못하는 키                          데이터베이스를 왜 사용할까요?            데이터베이스 이전에는 파일시스템을 사용하여 데이터를 식별하였습니다.  디스크 IO는 느리고, 실제 어플리케이션은 랜덤 IO를 많이 발생시킵니다.  이것을 해결하기 위해서 랜덤 IO를 순차 IO로 바꿔서 실행하는걸 통해 더 성능적 이득이 있습니다.          트랜잭션            트랜잭션은 무엇인가요? 왜 필요한가요?                    데이터베이스에서 논리적인 작업의 단위입니다.                                트랜잭션 특징                      원자성(Atomicity) : all or nothing           일관성(Consistancy) : 항상 동일한 결과           독립성(Isolation) : 다른 트랜잭션이 끼어들 수 없다           지속성(Durability) : 트랜잭션의 결과는 영구적으로 반영                       트랜잭션 격리수준                    _트랜잭션 격리수준이 왜 필요한가요? _                            트랜잭션은 ACID 원칙을 지켜야 하지만, 완벽하게 지키는 형태는 동시적인 요청에 대한 처리량이 떨어지게 됩니다. 따라서 데이터베이스는 애플리케이션 개발자가 본인들의 환경에 맞게 트레이드오프를 고려하여 선택할 수 있도록 격리레벨을 만들어두었습니다.                                    어떤 트레이드오프인가요?                                            동시적 처리량을 늘릴수록 이상현상이 더 많이 발생합니다.                                                    대표적인 이상현상을 말씀드리면 아래가 있습니다.                                                            DIRTY READ : 트랜잭션 실행도중 다른 트랜잭션의 업데이트에 의해 수정된 데이터를 읽는것                               PHANTOM READ : 동일한 쿼리에 대해서 두번째 쿼리에서 없던 결과가 나오는것                               NON REPEATABLE READ : 트랜잭션 실행도중 두번째 읽었을 때 다른 값이 나오는것                                                                                                                                                                   격리수준이 이 문제를 어떻게 해결해주나요?                                            Serializable : 모든 트랜잭션이 순차적으로 실행되도록 합니다 어떠한 문제도 일어나지 않습니다.                       Repeatable Read: MySQL의 기본 설정입니다.  변경 전 레코드를 언두 공간에 백업해두고 앞서 처리된 트랜잭션에 대해서는 언두 공간의 값을 읽게 합니다. 트랜잭션이 앞서 처리되었는지는 트랜잭션마다 번호를 부여하여 판단합니다. 일반적인 Phantom Read 또한 이후 트랜잭션 번호를 가진 언두로그를 봐서 무시하면 되지만 SELECT FOR UPDATE와 같이 같이 관여할 경우, 락은 언두로그가 아닌 테이블값을 읽기 때문에 Phantom Read가 발생할 수 있습니다.                       Read Commited : Commit된 데이터만 읽을 수 있도록 하는 설정입니다. Commit 된 데이터를 읽을 경우 Non Repeatable Read가 발생할 수 있습니다.                       Read Uncommited : Commit 되지 않은 데이터도 읽을 수 있도록 하는것. 모든 이상현상 발생.                                                                                                                           정규화            정규화란 무엇인가요? 왜 필요한가요?                    정규화란 데이터베이스 테이블들의 관계에서 중복을 최소화시키는 방법입니다.                       역정규화?                    테이블에 대한 조인이 성능적으로 문제가 되는 경우(경로가 멀어서)           조회에 대한 처리성능이 중요하다고 판단된다면                           인덱스            인덱스가 무엇인가요? 왜 필요한가요?                    데이터베이스는 랜덤 IO 엑세스와의 싸움입니다.   추가적인 쓰기작업과 저장공간을 사용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조를 의미합니다.           어떤 자료구조인가요?                            일반적으로는 B+ 트리를 이용합니다.                                    왜 B+ 트리를 이용할까요?                                            B+ 트리는 Leaf Node간 연결이 되어있기때문에                                                    FullScan과 Range Scan에 유리합니다.                                                                                                                                                                       인덱스의 성능 또는 고려해야할 사항?                    WHERE 절에 자주 사용되는 열           SELECT 절에 자주 등장하는 칼럼           JOIN에 자주 사용되는 열           데이터 중복도가 높은 열은 효과가 없음                            남성/여성                                   WHERE 절을 변형하면 인덱스를 안타는 이유                            결국 시작점을 알 수 없기 때문임 LIKE 또는 SUBSTR                                   복합 인덱스를 구성할 때 칼럼의 순서를 고려하는 기준                            분포도는 의미가 없다                                    연산자가 “=” 가 아닐 수 있기 때문                                               연산자를 최우선적으로 고려하라                                    분포도가 좋더라도 연산자가 선분조건이면 앞에 두는게 안좋을 수 있다는것                                                                                  ","categories": ["Interview"],
        "tags": [],
        "url": "/interview/ms_database1/",
        "teaser": null
      },{
        "title": "CS 면접대비 - 네트워크",
        "excerpt":"OSI 7계층            “OSI 7계층을 설명해주세요”                    Physical Layer - 케이블, 허브 : 전기신호 전송           Data Link Layer - 브릿지, 스위치 : MAC주소 부여!                            MAC 주소란?                                    하드웨어 장치의 네트워크 식별자 - 주민등록번호이며 변경되지 않음                                                                   Network Layer - 라우터, IP : 라우터를 통해 IP 주소를 지정                            IP 주소란?                                    컴퓨터 네트워크에 할당된 논리적 숫자 주소                                            IP 주소만으로 통신이 가능한가요?                                                    그렇지 않습니다. 로컬 네트워크 내부에서 어떤 하드웨어와 통신하는지 알기 위해서는 MAC주소를 알아야 합니다.                                                                                                                                       라우터의 역할은?                                    네트워크 자체를 연결시켜주고 최적화된 경로로 통신이 가능하게끔 하는 네트워크 장치                                                                   Transport Layer - TCP와 UDP 프로토콜을 통해 세그먼트를 전달           Session Layer - API, Socket : TCP/IP 세션의 생성 및 소멸           Presentation Layer - JPEG, MPEG: 데이터 표현 및 암호화           Application - HTTP, FTP, DNS : 응용 프로세스와 직접 관계하여 서비스 수행                       “왜 OSI 7계층으로 나누는 걸까요?”                    관심사의 분리 때문입니다. 문제가 발생했을 때 서로 독립적이여야 해결이 간단합니다.                           Multiplexing과 Demultiplexing이 무엇인가요?            L4 레이어에서 담당하는 역할로, Multiplexing이란 여러개의 어플리케이션의 소켓으로부터 나오는 요청들에 대해서  일종의 이름표인 Transport Header를 붙혀주는것입니다.       Demultiplexing은 반대로 Transport Header를 보고 적절한 소켓으로 전달해주는것을 의미합니다.          Stateless한것과 Connectionless 한것의 차이는 무엇인가요?            Stateless하다는것은 이전 요청에 영향을 받지 않고 매번 독립적이게 취급한다는 의미입니다.       Connectionless 하다는것은 TCP처럼 커넥션이 유지되는것이 아닌, 패킷이 독립적으로 취급되는 UDP와 같은 프로토콜을 의미합니다.          TCP가 Connection 기반 프로토콜이라면, 웹서버는 요청마다 새로운 소켓을 생성할까요?            링크 대체          TCP 프로토콜에 대해서 설명해주세요            TCP 프로토콜은 Transport Layer의 신뢰적인 연결방식 입니다.                    전송속도가 너무 빠를경우 수신측이 받아들이지 못해 손실이 나는것을 대비한 흐름제어           라우터의 데이터 병목 등으로 인해 처리할 수 없어 손실이 나는것을 대비한 혼잡제어                          UDP 프로토콜에 대해서 설명해주세요            UDP 프로토콜이란 비연결성, 신뢰성 없는 전송 프로토콜입니다.  각각의 데이터 패킷은 독립적으로 취급되며, 성공 또는 실패 여부와 관계없이 전송을 시도합니다.          TCP의 커넥션 수립 과정을 설명해주세요            TCP의 경우, 3-way handshake를 통해서 커넥션을 수립합니다. 과정은 아래와 같습니다.                    클라이언트 -&gt; 서버 : 커넥션 신청을 하기 위해서 SYN 패킷을 전송합니다 (seq=x)           서버 -&gt; 클라이언트 : 커넥션 신청을 받았다는것을 확인시켜주기 위해 ACK(x+1) 과 SYN(y) 를 전송합니다           클라이언트 -&gt; 서버 : 커넥션을 수립하기 위해서 ACK(y+1) 패킷을 전송합니다.                       4-way handshake는 커넥션을 종료하기 위해서 사용됩니다.                    클라이언트 -&gt; 서버 : FIN 플래그를 전송합니다.           서버 -&gt; 클라이언트 : FIN에 대한 ACK를 전송합니다.           서버 -&gt; 클라이언트 : 데이터를 모두 받았으므로 FIN을 전송합니다           클라이언트 -&gt; 서버 : FIN 에 대한 ACK를 전송합니다.                          Checksum은 무엇인가요?            전달된 네트워크 Segment에 문제가 있는지 검증하기 위해서 모든 Segment Header의 값을 더한것을 넣어둡니다.                    무엇을 더하는건가요?                            CRC의 경우 내용을 이진수로 취급하여 모두 더하고 상수로 나눈 뒤 사용합니다.               Summation의 경우 각 바이트를 정수형으로 취급하여 모두 더해주고 나머지 연산의 결과값을 사용합니다.                                   TCP와 UDP중 어떤 프로토콜이 checksum을 사용하나요?                            둘 다 사용합니다.                                   체크섬으로 오류를 복원할 수 있나요?                            불가능합니다. 오류의 완벽한 검출 또한 어렵습니다.                                                  주소창에 naver.com 을 입력하면 일어나는 일을 설명해주세요     네트워크 통신을 시도하는 것입니다. naver.com 에대한 IP 주소를 찾는것이 첫번째 목적입니다.             윈도우의 경우, hosts 파일을 먼저 참조합니다. 만약 명시적으로 도메인에 대한 매핑이 있다면 즉시 사용합니다.       없다면 이전에 접속한 이력이 있는지 RAM의 DNS 캐시를 참조합니다.       없다면 공유기를 통해서 ISP를 거쳐 DNS lookup을 시도합니다.       받아온 IP 주소를 보고 로컬 네트워크를 살펴봅니다. 대역대가 다르기 때문에 다른 네트워크로 보내기 위해 공유기를 찾아야 합니다.       공유기를 찾기 위해서 ARP를 합니다. 즉 브로드캐스팅을 하여 공유기의 MAC주소를 받아옵니다.       공유기에게 IP 주소로 메시지를 전달하라는 명령을 내립니다.       공유기는 최적의 경로를 찾아서 다음 라우터로 ARP 과정을 반복하며 메시지를 전송합니다.       받아온 IP 주소를 통해서 HTTP 프로토콜을 사용하기 위해서 TCP/IP 연결을 수립합니다.                    3-way handshake           데이터 전송           4-way handshake                       다운로드한 CSS/HTML/JS 파일들을 다운로드하고 브라우저에서 렌더링합니다.       HTML/CSS/JS 파일들을 디스크에 Caching 되며 다시 접속할 경우 캐시를 참조합니다.          공개키와 대칭키의 차이는 무엇인가요?            공개키는 암호화하기위해서 사용한 키와 복호화하기위해서 사용하는 키가 동일한 것을 의미합니다.       대칭키는 암호화하기위해 사용한 키와 복호화하기 위해 사용하는 키가 다른것을 의미합니다.          HTTPS는 어떤 키를 사용하나요?            대칭키와 비대칭키를 둘다 사용합니다.          TLS/SSL Handshake 과정을 설명해주세요            TCP 연결을 수립합니다.       C-&gt;S : Client Hello       C&lt;-S : Server Hello + CA 인증서       C : CA 인증서의 유효성 검증       C-&gt;S : 자신이 생성한 랜덤 대칭키를 인증서에 있는 서버의 공개키로 암호화하여 서버에 전송       S : 서버는 자신의 개인키를 이용하여 대칭키를 확보하고, 메시지를 해석                  만약 중간에 CA인증서를 공격자가 위조하여 가로채고 요청을 한다면 어떡하나요?                    결국 서버의 개인키를 알지 못한다면 가로채도 의미가 없습니다. 클라이언트가 사용할 데이터 암호화 키는 서버의 공개키를 이용하기 때문에 서버의 개인키가 없다면 해석 할 수 없습니다.                           로드 밸런서란 무엇인가요?            부하 분산 장치 또는 기술을 의미합니다.                    접속 요청을 사전에 할당한 VIP로 받아 요청을 분배해줍니다.                            중간에 서버 하나가 죽는다면 어떡하나요?                                    이를 확인하기 위해서 지속적으로 헬스체크를 수행합니다                                            ICMP : 직접 PING 을 날리거나 (3계층)                       TCP : 연결을 시도하거나 (4계층)                       HTTP : 요청을 시도하거나 (7계층)                                                                                       어떻게 균등하게 분배하나요?                                    Weighted Round Robin : 가중치가 높은 서버에 요청을 배분합니다. 처리성능이 각각 다를 경우                   Least Connection: 연결이 제일 적은 서버에 요청을 전달합니다.                   Hash : 특정 사용자가 동일 서버에 연결이 필요할경우 사용합니다.                                                                                  DSR이 무엇인가요?            동영상 스트리밍과 같이 나가는 트래픽이 들어가는 트래픽보다 클 경우 모두 로드 밸런서를 거쳐야 하기 때문에  로드 밸런서가 병목지점이 될 수 있기 때문에 로드 밸런서를 거치지 않고 서버에서 직접 응답하는것을 의미합니다.          GET과 POST 방식의 차이점?            GET의 경우 요청하는 데이터가 URL에 그대로 붙어서 노출되기 때문에 보안에 취약합니다. 추가적으로 URL의 길이는 한정되어있습니다.  동일한 요청의 경우 캐싱됩니다.       POST의 경우 request body 부분에 데이터가 담겨있으며 암호화를 한다면 GET보다 보안이 좋습니다.          CORS 문제를겪은적 있나요?            네. 동일한 하드웨어에서 프론트엔드와 백엔드를 둘다 실행시켰을 때  프론트엔드에서 백엔드로 요청을 하는경우 흔히 발생했습니다.                    왜 문제가 일어나는건가요?                            서로 다른 도메인간 정보를 공유하는것을 브라우저에서 보안적으로 막기 때문입니다.               프록시 또는 애플리케이션 코드에 CORS 설정을 열어두는 방식으로 해결 가능합니다.                                                  NGINX또는 APACHE는 어떤 계층인가요            HTTP웹서버들은 애플리케이션 레이어이며 HTTP는 TCP/IP 프로토콜을 이용하기 때문에 4계층입니다.         ","categories": ["Interview"],
        "tags": [],
        "url": "/interview/ms_network2/",
        "teaser": null
      },{
        "title": "CS 면접대비 - 객체지향 프로그래밍",
        "excerpt":"객체 지향 프로그래밍이 무엇인가요?             개념의 추상화에 대응하는 데이터와 코드를 보유할 수 있는 “객체” 와 그 객체간의 상호작용을 통해 프로그램을 작성하는 방법론           객체지향 프로그래밍의 장점이 무엇인가요?                      코드 재사용이 용이 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있다. _ 전형적인 절차형 언어들도 함수를 가져오면 재사용할 수 있는것 아닌가요? _ 재사용을 위해서 상속을 사용하는건가요?                        유지보수가 쉬움 절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 존재하기 때문에 해당 부분만 수정하면 된다.                        대형 프로젝트에 적합 클래스 단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러 명, 여러 회사에서 프로젝트를 개발할 때 업무 분담하기 쉽다.                        개인적으로는, 도메인을 객체라는 추상화로 보는것이 설계에 굉장히 유용하다고 생각함                   클래스와 인스턴스의 차이는 무엇인가요?                      플라톤의 이데아와 유사하게 추상화를 거쳐 데이터와 코드로 정의한것                        인스턴스는 클래스를 바탕으로 실제 메모리에 할당된 객체를 의미                   추상화란 무엇인가요?                      여러 클래스에서 사용하는 공통된 메소드, 혹은 요소들을 공통으로 묶어내서 규칙만 빼내는 행위?                        추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다                        추상화가 꼭 클래스에만 적용되는가?                     꼭 추상 클래스나 인터페이스를 통해서만 추상화가 가능한가?                           캡슐화란 무엇인가요?             변경될 가능성이 높은 부분을 객체 내부로 숨기는 추상화의 한 종류                    왜? 변경될 가능성이 높은 부분을 숨긴다면 “수정의 전파”가 이루어지지않음           메시지와 인터페이스 의존 원칙과도 연관됨           불안정한 = 변경이 잦은 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화                       캡슐화를 저해하면 무엇이 안좋은가?                    애초에 캡슐화가 무엇인가?                            객체의 행위와 필요한 상태를 하나의 클래스에 응집시키는것, 외부에서 알 수 없게 하는 것                                   지키지 않는다면 무엇이 나쁜가?                            내부 구현이 퍼블릭 인터페이스에 노출되게 된다               내부 구현의 변경이 외부 클라이언트로 전파된다 - 확장에 적합하지 않은 설계                                                   객체의 책임이란?             객체의 존재이유 = 협력에 참여 ⇒ 협력에 필요한 행동을 제공해야 함                객체는 상태가 아닌 행동을 통해 다른 객체와 협력               객체의 상태를 먼저 결정하고 상태에 필요한 행동을 정하는것은 캡슐화를 저해한다           객체의 협력이란?             객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용           객체의 역할이란?             객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.                    책임의 추상화                       역할에게 책임을 할당하라       사용하면 “유연하고 재사용 가능한 협력”을 얻을 수 있다 - 동일한 책임을 수행하는 객체를 추상화 하여 하나의 역할로 만든다          ","categories": ["Interview"],
        "tags": ["면접","객체지향"],
        "url": "/interview/ms_oop1/",
        "teaser": null
      },{
        "title": "CS 면접대비 - 운영체제",
        "excerpt":"프로세스와 스레드의 차이는?             개념의 추상화에 대응하는 데이터와 코드를 보유할 수 있는 “객체” 와 그 객체간의 상호작용을 통해 프로그램을 작성하는 방법론           프로그램이란?             프로그램이란 디스크에 저장되어있는 실행가능한 파일로, 코드 또는 명령어들의 집합이 담겨져있습니다.  프로그램을 실행하면, 디스크에 있는 명령어들은 메모리에 로드되고 이것을 프로세스 라고 부릅니다.           프로세스는 무엇을 갖고있나요?             프로세스는 프로그램을 실행시키기 위해서 코드/데이터/힙/스택의 메모리 구조로 구성되어 있습니다.  프로세스는 서로 격리되어있다는것이 핵심입니다.  개별적인 메모리 공간을 할당받으며, 하나가 불량으로 인해 실패하더라도 다른 프로세스에 영향을 주지 않습니다.  예를 들면, 크롬과 워드를 동시에 실행하다 워드가 오작동으로 종료되더라도 크롬에는 영향을 주지 않습니다.           스레드는 무엇인가요?             스레드란 프로세스 내부의 실행 단위입니다.  여러개의 스레드가 동시에 하나의 프로세스를 실행시키기 때문에 인터넷 브라우저에서 동영상을 보면서 동시에 파일을 다운로드하는것이 가능합니다.  개별적인 스택 영역을 가짐으로서 독립적인 실행 환경을 갖지만,  스레드끼리 코드, 데이터, 힙 세가지 영역은 공유합니다.           멀티스레딩과 멀티프로세싱의 차이점은 그러면 무엇인가요? 어떤게 더 빠를까요?             결국 멀티스레딩이라는건 하나의 프로세스 안에서 수행하는 병렬 작업이고,  멀티프로세싱은 여러개의 프로세스들을 별도의 프로세스에서 병렬로 수행하는것이다  둘간의 속도를 직접적으로 비교하는것은 의미가 없다. 결국 요구사항의 환경 차이로부터 속도의 차이는 발생한다.  둘의 차이를 생각해보자. 스레드들은 힙 메모리 영역을 공유하는것이 주요한 차이이다.           인터럽트는 무엇인가요? 왜 일어나나요?             CPU가 연산을 하는 중 IO 또는 예외상황 발생으로 인해 우선적인 처리가 필요하다는것을 알리는걸 의미합니다.  인터럽트가 필요한 이유는 IO 과정이 연산보다 매우 느리기 때문입니다.  만약 인터럽트가 없다면, CPU는 계속해서 해당 디바이스를 지켜봐야 할 것입니다.  Blocking / Non-Blocking과 연관지어도 좋습니다.  인터럽트를 일종의 콜백으로 본다면, NonBlocking Async 의 형태가 되는것이고  없다면 Blocking Sync의 형태가 될 것입니다.           동시성(Concurrency) 와 병렬성(Parallelism)에 대해서 설명해주세요?             병렬성은 여러개의 물리적인 하드웨어에서 여러개의 작업을 동시에 처리하는것이고,  동시성은 하나의 하드웨어에서 여러개의 프로그램들을 동시에 수행하는것 처럼 보인다           그렇다면 싱글코어 컴퓨터에서 어떻게 멀티프로세싱을 수행하나요?             하나의 프로세서가 존재하더라도 짧은 time slice 안에 여러개의 프로세스를 번갈아가면서 수행하면 우리에게는 동시에 여러개의 프로세스가 수행되는것처럼 보인다.           하나의 프로세스에서 다른 프로세스로 어떻게 전환할 수 있나요?             짧은 시간 안에 프로세스를 전환하기 위해서는 상태를 보존하는 자료구조가 필요한데, 이를 PCB(Process Controll Block) 이라고 부르며, 전환하는 행위를 Context Switching 이라고 부른다.           PCB 내부에는 프로세스의 상태를 저장하는 다양한 정보가 들어있습니다 (program counter, register, pid, …)       해당 PCB를 이용해 다른 프로세스로 전환하고 다시 돌아왔을 때 프로세스의 상태를 복구시켜준다       Context Switch 가 그러면 어떨 때 일어나나요?             배정된 time slice가 만료되거나, 프로세스의 상태를 변경시키는 IO작업의 대기, 또는 우선순위가 높은 작업의 출현 등으로 인해 일어날 수 있습니다          Context Switch가 일어나면 현재 상태는 어떻게 저장되나요?             https://stackoverflow.com/a/68055967           프로세스의 진행 중 스위칭이 일어날 경우 현재의 실행 컨텍스트는 (프로세스의 상태나 프로그램 카운터) 커널 스택에 저장됩니다 PID등 프로세스에 관련된 정보는 PCB에 저장됩니다              PCB와 커널 스택 둘다 Context Switch 시에 필요한 정보를 담고 있다. 어떤 값을 들고있는지는 OS마다 다르고, 정확하게 정할 수는 없다.       PCB는 일반적으로 Kernel Stack 내부에 존재한다           그렇다면 스레드에도 PCB가 존재하나요?                      https://stackoverflow.com/a/68055967                        PCB의 명칭상 스레드에 PCB가 존재한다고는 말할 수 없지만, TCB라는 유사한 저장소가 존재한다  PCB와 유사하게 stack pointer, register 등 TCB에도 스레드의 상태를 기록하는 정보들이 존재하며, 프로세스보다는 작은 규모이다.                   Kernel Level Thread 와 User Level Thread 의 차이는 무엇인가요?      https://stackoverflow.com/a/59634931       인터넷에 정확한 설명이 매우 부족한 부분인데, 간혹 나오는것같아 첨부한다  Kernel을 동작시키는 스레드 != Kernel 스레드  원점으로 돌아가보자. 하나의 코어를 갖고 있는 시스템에서 커널은 어떤 작업을 하는가?  여러개의 스레드가 연속적으로 context switching을 수행해주는걸 관리해준다.  Kernel 스레드는 어디까지나 이 개념을 조금 확장한것일뿐이다.       하나의 프로세스는 하나의 커널 스레드를 보유한 상태에서 시작한다. 즉, 싱글 스레드 앱이라면 모든 작업이 커널 스레드에서 수행된다. 당연하게도 PCB는 여기서 관리한다       하지만 프로세스를 여러개의 유저 스레드라는 일종의 유사 스레드로 실행될 수 있다.  일반적으로 라이브러리 등을 통해 생성되는 유저 스레드는 OS에서 관리하는 실제 스레드와는 다른 유사 스레드이다. 해당 유저 스레드의 스케쥴링은 라이브러리의 정책에 따라 관리되며 커널은 해당 프로세스의 분기에 대해서 전혀 알지 못한다 (하나의 프로세스로 볼 뿐)         운영체제 / IPC   IPC에 대해서 설명해주세요      프로세스는 서로 격리되어있기 때문에 스레드와 같이 힙, 코드, 데이터 영역등을 공유하는 방식으로 소통할 수 없습니다.  따라서 별도의 통신 메커니즘을 이용하는데, 이것을 IPC라고 부릅니다.  아래와 같이 로컬 통신 방식              Pipe를 이용한 Message passing                    단방향 통신만 가능한 익명 파이프                            양방향 통신을 위해서는 두개의 파이프 (read - write)전용 파이프를 만들어야 한다                                   양방향 통신이 가능한 명명 파이프                                공유 메모리 사용                      파이프만으로 해결할 수 없는 경우 사용           동시성 문제를 주의해야 함                           또는 네트워크 통신 방식인              소켓 통신       RPC                    Remote Procedure Call                            클라이언트에서 서버에 위치한 프로시저를 호출할 수 있게 하는 프로토콜                                                   등이 있습니다.       프로세스 스케쥴링 알고리즘에는 뭐가 있나요?                      가장 단순한 FIFO부터 설명드리겠습니다. 먼저 들어온 작업이 먼저 끝나는 형식의 FIFO는 단순하지만, Convoy Effect라는  오래 걸리는 프로세스가 앞에서 점유하고 있을 경우, 뒤 작업들의 처리시간이 늘어나는 문제가 있습니다.  이것을 극복하기 위해서 Shortest Job First 라는 가장 짧은 시간이 걸리는 프로세스를 먼저 처리하는  방법이 존재하지만 역시 starvation 문제가 있습니다.                        이 문제들을 해결하기 위해서 프로세스를 중간에 가로채는 선점 스케쥴링 방식이 등장합니다.  예시로 Round robin이 있지만, 이 경우 또한 Context Switching 비용을 신경써야 합니다.                   데드락에 대해서 설명해주세요             두개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 못하는 상태를 의미합니다.  예를 들어 A와 B가 두개의 종이에 쓰여 있는 숫자 두개를 더하고 싶을 때,  A가 종이1을 얻고 B가 종이2를 얻었을 때 서로 다른 종이를 얻기 위해 기다리는 상황입니다.           경쟁 상태에 대해서 설명해주세요             공유 자원에 대해서 두개 이상의 프로세스나 스레드가 접근할 때 생길 수 있는 문제를 의미합니다. 덧셈 코드가 load/add/store로 나뉘어 있는것을 생각하면 설명하기 좋습니다.  경쟁 상태를 해결할 수 있는 방법으로 Mutual Exclusion이 있는데, 이것은 데드락의 발생조건 중 하나입니다.           Mutex와 Semaphore             경쟁상태를 해결하기 위해서 일종의 락을 데이터에 걸어주는 것입니다.  화장실과 화장실 키를 생각해볼 수 있습니다.  하나의 프로세스가 Mutex를 보유했을 때, 다른 프로세스는 접근할 수 없습니다.  세마포어는 이것의 확장입니다.  P(S)로 Semaphore를 감소시키면 busy waiting 하거나 대기 큐로 옮기고 V(S)로 Semaphore를 증가시키면 대기 큐에서 P를 꺼내 실행시킵니다             파일 시스템   파일 시스템이란 무엇인가요?             디스크에 접근하는것을 OS 레벨에서 추상화한 것입니다.           프로세스에서 파일을 어떻게 읽나요?             디스크에 접근하는것을 OS 레벨에서 추상화한 것입니다.                  파일 열람을 위한 시스템 콜이 호출됩니다.                  파일의 경로와 읽기 모드를 명시하면 운영체제에서 파일 open 시스템 콜을 호출합니다.       파일을 성공적으로 읽었을 경우, file descriptor 가 반환됩니다.                    file descriptor란 현재 열려있는 파일의 식별자로 사용되는 정수값입니다.                       파일 내용을 읽기 위해서 read 시스템 콜이 호출됩니다.  읽은 내용은 버퍼로 옮겨집니다.       파일 시스템을 통해서 저장장치에 있는 정보를 읽고, 프로세스의 메모리로 복사됩니다.       읽은 파일의 총 바이트 수를 반환합니다.       close 시스템 콜을 날려 파일을 닫습니다.             페이지   페이징이 왜 필요한가요?     ","categories": ["Interview"],
        "tags": ["면접"],
        "url": "/interview/ms_os1/",
        "teaser": null
      },{
        "title": "영속성 핥아보기",
        "excerpt":"영속성이란     영원히 계속되는 성질이나 능력   영속화 : 어플리케이션의 상태와 상관없이 물리적인 저장소에 데이터를 저장하는 행위            데이터를 어떤 공간에 어떤 형태로 저장할 것인가?       RDMBS에 데이터를 저장하는 방법은 SQL이라고 볼 수 있다           자바의 경우     자바 어플리케이션에서는 JDBC 인터페이스를 사용            각 데이터베이스 제조사들은 JDBC 인터페이스를 구현하는 클래스(드라이버) 들을 제공       순수 JDBC를 사용할 경우                    데이터베이스 접속, 질의, 유저 객체로의 변환 절차가 필요           모두 동일한 파일에서 관리해야 한다                            칼럼의 이름명이 변경 등 사소한 테이블의 변경이 sql 문자열에 전파됨                                                   객체와 테이블의 불일치     객체지향 어플리케이션과 RDBMS의 불일치를 맞추는데 많은 리소스 소모   이를 해결해주는것이 Persistence Framework            SQL Mapping (MyBatis - 실제 SQL 코드와 비즈니스 로직의 분리)                    .xml 형태로 외부로 빼내준다                       OR Mapping (객체와 관계형 데이터베이 사이의 매핑, SQL을 생성)           JPA     JPA를 통해 객체를 영속화 하려고 사용하는것이 EntityManager이고, EntityManagerFactory를 통해 얻음   EntityManager는 영속성 컨텍스트를 통해 영속 객체를 관리            영속 객체 = 실제로 데이터가 영속적으로 저장되기 위한 객체                    Customer c = new Customer()가 entityManager를 통해 영속성 컨텍스트에 등록되고  트랜잭션 내에서 관리되다가 끝났을 때 데이터베이스 안으로 등록된다                           사용자는 EntityManager 인스턴스 객체의 메소드를 이용해 영속 객체를 관리   근데 왜 실제로 EntityManager EntityManagerFactory 실제 코드에서는 없음 ?            이런 작업들은 Spring Framework에 위임할 수 있음           영속성 컨텍스트 - INSERT AND SELECT     고유 ID를 갖는 모든 영속 객체 인스턴스에 대한 집합   EntityManagerFactory emf = Persistence.createEntityManagerFactory(); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction();  Customer customer = new Customer(); //아직 일반객체 em.persist(customer); //이제 등록됨 (1차 캐시) 아직 INSERT는 X em.persist(customer); //캐시에 이미 해당 객체 있어서 do nothing  Customer c1 = em.find(Customer.class, \"ID0001\"); // SELECT X, 1차 캐시에 있는 데이터를 받아온다  tx.commit() //이순간 INSERT 발생      모든건 트랜잭션 안에서 일어난다            transaction 내부에서 persist가 일어나야 1차 캐시에 들어가있는것           괜히 캐시라고 부르는게 아니다            entityManger.find 의 경우, Persistence Context에 있다면 그녀석을 가져오고       만약 없다면 db에 select문을 날려서 가져온다                    select 문을 통해 가져온 객체는 다시 persistence context에 보관된다                           SQL 저장소            persist 메소드가 호출될 경우, SQL 저장소(쓰기 지연)에 SQL 저장됨                    flush / transaction commit 시점에 저장되어있는 SQL들을 실행                           영속성 컨텍스트 - UPDATES     객체의 상태 변경            UPDATE 쿼리들은 마찬가지로 SQL 저장소에 보관 후 커밋 시점에 반영       foundCustomer.setName(\"Kim\") 할경우, 현재 객체와 snapshot의 상태와 비교하고,    만약 다를 경우 UPDATE 쿼리를 SQL 저장소에 저장함           Flush     영속성 컨텍스트의 내용을 데이터베이스와 동기화 하는것   flush 방식            EntityManager.flush() 직접 호출       트랜잭션의 커밋       JPQL 쿼리 실행           flush를 실행하더라도 영속성 컨텍스트 내용은 유지됨   flush가 실행되더라도, 데이터베이스 내용이 완전히 변경된것은 아님            transaction이 완성되어서 롤백이 안되는 시점까지 간 것이 아니다       커밋하기 이전, 쿼리가 “반영된 시점”까지를 의미함           tx.begin() try {     Customer customer = new Customer(\"ID001\", \"KIM\");     em.persist(customer);     // 이 시점에는 우리의 java application에서는 persistence context와 db 동기화     // 하지만 다른 어플리케이션 (h2 console) 에서는 tx.commit()을 하지 않는이상 반영 X      tx.commit();     // 이 시점 이후로는 반영 완료 } catch(Exception e) {     tx.rollaback(); }  ","categories": ["JPA"],
        "tags": [],
        "url": "/jpa/persistance/",
        "teaser": null
      },{
        "title": "웹 서버와 포트, 소켓, 그리고 스레드",
        "excerpt":"웹 서버와 포트, 소켓, 그리고 스레드       지금까지 웹서버를 설정할 때 아무 생각 없이 포트 설정을 해 왔다.  Nestjs 라면 아래와 같이,   // main.ts async function bootstrap() {   const app = await NestFactory.create(AppModule);   await app.listen(3000); //  port } bootstrap();   SpringBoot라면   //application.properties server.port=8080   이런 식으로 말이다.   이번에 네트워크 관련 스터디를 하면서 포트와 소켓, 그리고 스레드에 대해서 몇가지 의문들이 들었는데, 이번 포스팅에서 하나씩 해결해보려고 한다.     먼저 한가지 질문으로 시작해보려고 한다.      소켓은 하나의 포트와 매칭되는가?    그렇다. 포트와 IP 주소를 조합하여 하나의 소켓을 구성한다.      하나의 요청은 하나의 소켓을 갖는다?    당연하게도 그럴것 같다. 서로 다른 요청들을 구분하고 TCP 연결을 맻으려면 서로 다른 포트(소켓)을 가져야 한다.   웹서버를 구축할 때 설정한 포트는 하나인데?   여러개의 요청을 동시에 처리하려면 당연히 여러개의 포트를 사용할것이다.  우리가 웹서버 애플리케이션에 배정한 포트는 하나인데, 어떻게 여러개의 동시 요청들을 처리하는걸까?   Listening Port   사실 우리가 서버를 구축할 때 주는 포트번호는 Listening Port라는 특수한 포트이다.  이 포트는 클라이언트들로부터 들어오는 연결 요청을 기다린다.  즉, 우리가 설정한 포트는 어디까지나 중재자 역할을 할 뿐, 직접 요청을 처리하는것이 아니다.       Ports and Sockets   웹서버는 listening port를 이용해서 요청을 기다린다.  요청이 들어올 경우, 받은 요청에 ephemeral port(~1024의 예약 포트를 제외한 나머지) 라고 하는 임시 커넥션 포트를 사용하여 동적으로 소켓을 만들어준다.   생성된 소켓은 톰캣과 같은 멀티스레드 웹서버 환경에서는 보유하고 있는 스레드 풀에서 스레드를 배정받아 요청을 처리하고,  Nodejs 와 같은 싱글스레드 환경이라면 이벤트 루프가 request handler를 호출하여 해당 요청을 처리해준다.       Concurrency   포트개수가 많긴 하지만 결국 6만개밖에 없는게 아닌가? 만약 그 이상의 연결이 들어온다면 웹서버는 요청을 받을 수 없는걸까?   그렇지 않다. 웹서버는 5개의 원소를 가진 tuple을 통해 connection을 구분한다.  Source IP, Source Port, Destination IP, Destination Port, Protocol 이중 하나라도 다르다면 별도의 connection으로 취급하는 것이다.   즉, 두 서버간 총 64K의 Connection이 가능하다는 의미이다.   따라서 포트 하나만 있더라도 서버의 리소스만 충분하다면 Source IP 주소가 모두 다르기 때문에 문제가 없다.       쉬어가기 - Processes and Threads   옛날 웹서버들은 사실 하나의 연결당 하나의 프로세스를 배정하는 process-per-connection 정책을 사용하였다.  다만 IPC와 프로세스 생성 / 해제의 오버헤드로 인해 프로세스가 아닌 스레드를 배정하는  thread-per-connection 정책을 사용하거나, nodejs와 같은 비동기 방식을 채택하였다.       HTTP/1.1 - Connection Overhead   연결 요청마다 매번 새로운 소켓을 생성하고 TCP 요청을 수립하는것은 당연히 비효율적일 것이다.  이를 해결하기 위해 HTTP/1.1 스펙에서는 Keep-alive라는 옵션이 추가되어, 연결을 재사용하는것이 가능하게 되었다.       Thread per connection vs Thread per request   다시 스레드로 돌아가보자.  연결 하나당 스레드 하나가 배정된다면, 연결 사이사이에 스레드가 놀지 않을까?   사실 현재 웹서버들은 하나의 “연결”에 대해서 스레드를 배정하지 않고, 하나의 “요청” 단위로 스레드를 배정한다(Thread per request)   요청 단위로 스레드를 배정한다면 생성비용과 해제비용은 어떻게 감당할까?  앞에서 잠깐 이야기했듯, 멀티스레드 웹서버들은 스레드풀을 사용하여 관리한다.  이게 가능한 이유는 http의 stateless한 특성 때문이라고 이해할 수 있다.   생각해보기 - KeepAlive &amp; Thread per request?   HTTP/1.1의 KeepAlive는 추가적인 요청에 대해서 연결을 재활용하기 위해 바로 스레드가 반납되지 않고 잠깐 살아있게 된다.   이게 Thread per request 모델과 공생이 가능할까?   스레드를 재활용하는것은 엄격하게 보면 Thread per connection이 아닐까?  ","categories": [],
        "tags": [],
        "url": "/web_servers/",
        "teaser": null
      },{
        "title": "CS 면접대비 - 컨테이너",
        "excerpt":"도커가 왜 필요할까요?            옛날 이야기를 잠깐 하면                    옛날에는 서버를 관리하는게 쉽지 않았습니다           새롭게 설치해야하는 프로그램은 많고           운영체제는 업데이트되고           그와중 프로그램끼리 호환이 안되는 경우도 많고           지금 당장 리눅스에 MySQL을 까는건 쉽지 않습니다           이런 문제들을 해결해보기 위해서 VM이라는게 먼저 나왔습니다.                          그렇다면 VM은 뭔가요?                      동일한 하드웨어에서 여러개의 운영체제 인스턴스를 돌려보자 라는 의도의 결과입니다.                      마치 냉장고 안에 냉장고를 넣듯이, 서로 완벽하게 격리되어있고 OS 정보들을 모두 보유하고 있습니다.           각 VM은 호스트로부터 Hypervisor를 통해서 가상 하드웨어와 어댑터를 할당받아서 실제 여러개의 하드웨어가 없더라도 공유할 수 있도록 합니다.           윈도우에서 C드라이브의 Windows 폴더 전체                   그렇다면 VM으로 말씀하신 내용을 다 커버할 수 있는거 아닌가요?                             물론 가능은 합니다만, VM에는 비효율성이 몇가지 있습니다.                                    운영체제 파일 자체를 요구하기 때문에 고정된 하드디스크 요구량과 메모리                   시작하는데 OS별 부팅과정을 거치기 때문에 오래 걸리고                   별도의 커널/라이브러리/바이너리가 다 필요하기때문에 리소스를 많이 먹습니다                                                                사람들은 이 발상을 하게 됩니다 : 굳이 별도의 커널과 OS로 다른 어플리케이션을 실행해야 할까?                                      따라서 도커가 등장합니다                   도커는 일종의 VM으로 리눅스 커널을 이용하여 하위 컨테이너들을 분리합니다.                                   도커는 일종의 VM? 맞나요?                                                                     VirtualBox나 VMWare같은 VM이라기보다는, 도커 엔진이 가상화된 리눅스 환경을 구현해줍니다.     - 윈도우같은경우에는 내장되어있는 hyper-v를 사용합니다.     - 맥의 경우에도 리눅스 커널을 에뮬레이팅 해주는 애플리케이션을 사용합니다. HyperKit                           컨테이너는 매번 OS파일들을 보유할 필요가 없습니다.                                                      마치 냉장고에 야채칸, 계란칸, 김치칸 칸막이를 만드는 것처럼 입니다.                                                                                                           도커는 어떻게 그러면 프로세스를 격리하나요?                                            제가 알고있는바로는 리눅스의 Cgroup과 namespace 기능을 활용하는것으로 알고있습니다.                                                                                                 도커는 그럼 어떻게 그런 운영체제의 버전이나, 다양한 운영체제의 종류를 적은 용량을 통해 저장하나요?             Aufs라는 특별한 파일 시스템을 사용하고, 해당 도커파일을 빌드해서 사용합니다.          ","categories": ["Interview"],
        "tags": ["면접"],
        "url": "/interview/ms_container/",
        "teaser": null
      },{
        "title": "CS 면접대비 - 프로그래밍 언어(자바)",
        "excerpt":"❓Call by Value 와 Call by reference의 차이가 무엇인가요?      참고 : 현대의 CS개론에서 call by value 와 call by reference 에 대한 구분은   더이상 활발하게 이루어지지 않는다.   Pass by reference로 정의되던 방식이 사용되는 경우가 드물기 때문.    Value 와 Variable의 차이는 무엇인가?   이 질문에 정확히 대답을 할 수 있어야 한다.      Value(값)란, 표현식의 결과값을 의미한다   Variable(변수)이란, value를 담는 그릇이다   즉 int arg = 1; 라는 표현식에서 value는 1, variable은 arg라고 볼 수 있다.   Parameter 와 Argument의 차이는 무엇인가?      Parameter란 함수 호출을 위해 caller가 공급하는 variable   Argument란 함수 호출에 사용되는 parameter에 제공되는 value   Call by Value   Call by Value에서, 함수의 parameter들은 함수의 호출을 위해 함수의 argument로 초기화되어 새롭게 생성된 variable들이다.   “값”으로 초기화된 “변수” 들의 관계와 동일하다.   int arg = 1; int another_variable = arg;  //another_variable = 2; 가 arg에 영향을 주는가? 그렇지 않다.   void foo(int param) {     param += 1; } void bar() {     int arg = 1;     foo(arg); } // 해당 함수의 호출 결과는 일반적인 변수들의 관계와 동일하다 // \"새롭게 생성된 변수\" 라는걸 기억하자 ! int arg = 1; int param = arg; param += 1; // 이때 arg 와 param은 서로 다르다!   Call by Reference   Call by reference에서는 함수의 parameter들은 단순히 “alias”로 취급된다.   int arg = 1; // foo 함수 진입 // param 은 arg 랑 같네? arg /* param */ += 1;   여기까지 이해했다면 자바로 다시 돌아가보자   public void foo(Dog d) {     d = new Dog(\"Fifi\"); } Dog aDog = new Dog(\"Max\");  foo(aDog); // 함수 호출 이후 aDog가 가리키는 값은 여전히 \"Max\"이다 // d 가 aDog의 alias로 작동하는가? 그렇지 않다.    혹자는 이렇게 반론할지도 모른다.   public void foo(Dog d) {     d.setName(\"Fifi\"); } // 개의 이름이 변경되었다.   하지만 이것 또한 call by reference를 의미하는것은 아니다.  어디까지나 Dog 객체에 대한 “포인터”를 전달한것일 뿐, 실제 Dog 객체를 전달한 것이 아니기 때문이다. 즉 “포인터” 와 “reference”는 서로 다른 개념이다.   public void foo(Dog someDog) {  // AAA     someDog.setName(\"Max\");     // BBB     someDog = new Dog(\"Fifi\");  // CCC     someDog.setName(\"Rowlf\");   // DDD }  Dog myDog = new Dog(\"Rover\"); foo(myDog);   Dog객체가 메모리 주소 0x42에 있다고 가정해보자.      AAA            someDog라는 인자값이 0x42로 설정 (새로운 변수!)           BBB            someDog는 포인터를 따라가면 Dog객체가 있는 0x42에 도달하고, 이름 변경을 요청           CCC            someDog의 값은 0x74로 변경           DDD            0x74에 있는 Dog객체의 이름 변경을 요청           함수 호출이 된 이후의 결과를 생각해보자 myDog라는 변수가 변경되었는가? 그렇지 않다. 42를 유지하고 있다.   Thinking Point      Java로 전형적인 swap함수를 작성할 수 있는가?    설명이 많이 복잡했는데, “자바는 primitive의 경우 call by value, 이외는 call by reference 로 동작합니다”  라는 답변이 왜 잘못되었는 지 알 수 있길 바란다.   출처      https://stackoverflow.com/a/34971934   https://www.javadude.com/articles/passbyvalue.htm   &lt;/div&gt;&lt;/details&gt;   String, StringBuilder, StringBuffer   String   String s = new String(\"Hello\");   안좋은 선언이라고 알려져 있는데, 왜 쓰지 말라는 걸까?   두 객체의 차이는 뭘까? String s1 = \"Hello\"; String s2 = new String(\"Hello\");   펼치기      이유는 String의 특성에 있다.  자바의 String 객체는 불변객체이다.  덕분에 JVM은 굳이 동일한 내용을 가진 문자열들을 따로 힙에 저장하지 않고 String Pool이라는 곳에 하나만 저장하고 해당 문자열의 주소값만 전달하는 방식으로 메모리를 최적화할 수 있다.  이 과정을 “Interning” 이라고 한다.       반면 new String 의 문자열 생성자를 사용한 경우는 힙에 해당 문자열을 생성하게 되고, 서로 다른 주소값을 보유하게 된다. 이로 인해 메모리 낭비가 이루어지기 때문에 피하는 것이 좋다.       //자바의 String은 intern() 메소드를 제공한다 String s1 = \"Hello\"; String s2 = new String(\"Hello\").intern(); // 하지만 두 표현식이 동일하지는 않다. // intern() 메소드를 사용하더라도 힙에 올라간 메모리는 GC가 회수할때까지 남아있게 된다.                          String Pool 의 위치            Java7 이전까지는 String Pool이 고정된 크기를 가진 PermGen 영역에 존재하였다.  지나치게 많은 문자열들이 intern 될 경우, JVM이 OutOfMemoryError를 만들어내는 경우가 있어,  Java7 이후부터는 Heap 영역에 저장되도록 변경되었다.              https://muratakkan.medium.com/understanding-and-using-the-java-string-pool-in-java-d60d3176716            StringBuffer &amp; StringBuffer       String의 불변성은 앞서 말한 바와 같이 장점이 존재하지만, 단점 또한 존재한다.  바로 문자열 연산에 약하다는것인데, 문자열 두개를 더하는 연산같은 경우 불필요하게 두개의 문자열이 모두 Heap에 올라가야하는 비효율이 존재한다.       Java는 이 문제를 StringBuilder 와 StringBuffer라는 클래스를 두어 해결한다.  가변성을 보유한 StringBuilder 클래스는 append, reverse 등 다양한 mutate method를 제공한다.  또한, String 간의 연산 또한 연산자 오버로딩을 통해서 내부적으로는 StringBuilder를 사용한다.       StringBuffer와 StringBuilder의 차이는 무엇일까?      StringBuffer의 경우, 동기화를 지원하며 이에 대한 tradeoff로 연산속도가 느리다. StringBuilder의 경우, 동기화를 지원하지 않지만, 연산속도가 빠르다.           왜 이런 결과가 나올까?   String str1=\"str\"; String str2=\"ing\"; String concat=str1+str2;  System.out.println(concat==\"string\"); //false  vs  final String str1=\"str\"; final String str2=\"ing\"; String concat=str1+str2;  System.out.println(concat==\"string\"); //true    펼치기             최적화 할 수 있을까?   String s = \"\"; for (int i = 0; i &lt; 100; i++) {     s += \", \" + i; }    펼치기       ❓접근제어자      public : 어디서든 접근 가능   protected : 동일 패키지 + 상속받은 클래스 내부   default : 동일 패키지 내부   private : 동일 클래스 내부   package tut02; public class CA {     public int ia;     protected int ib;     int ic;     private int id; } //tut2 패키지 내의 클래스 CA 외부에서 접근 가능한 변수들은 ? //tut2 패키지 내의 클래스 CA 내부에서 접근 가능한 변수들은 ? //tut2 패키지 내의 클래스 CA를 상속받은 CAA 내부에서 접근 가능한 변수들은 ?   package tut03; import tut02.CA;  public class Tut03 {     public static void main(String[] args) {         CA a = new CA(); -&gt; 여기서 접근 가능한 변수들은?         CC c = new CC(); -&gt; 여기서 접근 가능한 변수들은?     } }    해답              ia, ib, ic       ia, ib, ic, id       ia, ib, ic           같은 패키지 내에서는 public protected default가 같은 효과를 갖는다!        ❓Lambda &amp; Stream   자바스크립트를 접해봤다면 함수형 패러다임을 구현하는데 유용한 map, reduce, filter등의 유용한 메소드들에 익숙할 것이다.  자바도 버전 8부터 Lambda 익명함수들을 지원하기 시작했다.   Priority Queue의 구현이나 Custom sort 등에서 이미 많이 사용하는걸 보았을 것이다   //Instead of this Collections.sort(listDevs, new Comparator&lt;Developer&gt;() {     @Override     public int compare(Developer o1, Developer o2) {         return o1.getAge() - o2.getAge();     } }); //We can do this listDevs.sort((o1, o2)-&gt;o1.getAge()-o2.getAge());   자바스크립트에서 이런 코드를 본적이 있을것이다.   function calculate(x, y, operatorFunction) {   return operatorFunction(x, y); } function add(a, b) {   return a + b; } calculate(1, 2, add);   자바스크립트는 함수가 일급객체이기때문에 아무 조작 없이 해당 코드가 실행 가능하다.  하지만 엄격한 자바의 세계에서는 그렇지 않다.  람다식을 사용하기 위해서는 어떤게 필요할까?   함수형 인터페이스   단 하나의 추상 메소드만 정의되어있는 인터페이스를 함수형 인터페이스라고 부른다   람다식으로 사용하기 위해서는 대상이 함수형 인터페이스여야만 한다  이유는 당연하게도(?) 메소드가 하나만 있어야 람다식이 수행하는 대상을 알 수 있기 때문이다.   @FunctionalInterface interface OperatorFunction {     int operate(int x, int y); }  public static int calculate(int x, int y, OperatorFunction operatorFunction) {     return operatorFunction.operate(x, y); }  int result1 = calculate(1, 2, (a, b) -&gt; a + b);   매번 유사한 함수형 인터페이스를 선언하는건 번거롭기때문에 자바에서는 util 패키지에서 사전에 정의된 인터페이스들을 제공한다.   //example : IntBinaryOperator를 사용하면 굳이 정의안해도 됨  //package java.util.function @FunctionalInterface public interface IntBinaryOperator {      /**      * Applies this operator to the given operands.      *      * @param left the first operand      * @param right the second operand      * @return the operator result      */     int applyAsInt(int left, int right); }  public static int calculate(int x, int y, IntBinaryOperator operator) {         return operator.applyAsInt(x, y); }   돌이켜보면 Sort에서 람다를 사용할 때는 별도의 인터페이스를 선언하지 않았다. 왜일까?  이유는 Sort 메소드의 두번째 인자인 Comparable가 compare라는 하나의 메소드를 가진 함수형 인터페이스이기 때문이다.   ❓Wrappper Class   자바에서는 일반적으로 알려진 Primitive Type들 (int, boolean, char … ) 에 대해서 Wrapper 클래스들을 제공한다.      똑같은 자료형인거같은데, 왜 필요할까?       ArrayList 등의 Collection 프레임워크들은 객체들의 메모리 위치를 저장하기 때문이다            실제로 ArrayList 구현의 생성자를 보면 다음 코드가 들어있다         public ArrayList(int initialCapacity) { super();     if (initialCapacity &lt; 0)         throw new IllegalArgumentException(\"Illegal Capacity: \"+                                         initialCapacity); this.elementData = (E[])new Object[initialCapacity]; }                           멀티쓰레딩의 동기화 지원   null 값의 존재   값 컨텍스트가 초래하는 영향            한번 값을 사용하면 어딘가에서는 계속 필요           ❓Overriding &amp; Overloading           superclass 에 이미 존재하는 메소드를 subclass에서 동일한 이름으로 사용하고 싶지만, 구현체는 바꾸고 싶을 경우 Overriding을 사용            Overloading은 superclass에 존재하지 않는 새로운 메서드를 subclass에서 선언하는것을 의미       생각해볼거리      왜 자바는 static method에 대한 오버라이딩을 허용하지 않을까?   왜 자바는 operator overloading이 없을까?  ","categories": ["Interview"],
        "tags": [],
        "url": "/interview/ms_java1/",
        "teaser": null
      },{
        "title": "영속성 까보기 (feat. 10분 테코톡)",
        "excerpt":"JPA와 영속성   JPA 영속성 관련 실험 중 이상한 케이스를 발견했습니다.  우아한형제들 테코톡의 문제상황 1에서도 비슷한 예제가 있습니다.  영상에서는 정확히 이유를 설명하지는 않고 영속성 설명으로 넘어가버려서 정확한 이유를 정리해보려고 합니다.   @Getter @Entity @AllArgsConstructor @NoArgsConstructor(access = AccessLevel.PROTECTED) public class Person {     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;      private String name;      public Person(String name) {         this.name = name;     } }   @DataJpaTest @TestMethodOrder(MethodOrderer.OrderAnnotation.class) class PersonRepositoryTest {     @Autowired     private PersonRepository personRepository;      private static final Person JOHN = new Person(\"John\");       @Test // Test 1     @Order(1)     void saveAndCompare() {         Person person = personRepository.save(JOHN);         assertThat(person).isEqualTo(JOHN);     }      @Test // Test 2     @Order(2)     void find() {         Person person = personRepository.save(JOHN);         assertThat(person).isEqualTo(JOHN);     }  }   결과  위에 작성되어있는 Person 클래스의 테스트 코드인  Test1 과 Test2를 각자 돌렸을 때는 성공하지만,    동시에 돌리게 되면 실패합니다.   일반적으로 @DataJpaTest에는 @Transactional이 달려있기 때문에,  하위 테스트들 모두에 @Transactional이 적용됩니다  @Transactional이 걸린 테스트들은 테스트 마지막에 rollback이 된다는 사실도 알고 있죠.  트랜잭션이 롤백되면 영속성 컨텍스트도 초기화되어 직관적으로는  두개 다 성공하거나 두개 다 실패해야 할 꺼라고 생각되는데,  왜 둘 중 하나만 성공하는걸까요?   영속성 컨텍스트가 동기화가 되지 않은걸까요?  하지만 em.flush() 와 em.clear()을 Test1 마지막에 추가하더라도   결과가 동일한것을 볼 수 있을 것입니다.   왜 실패하는지 그 이유에 대해 단계별로 쪼개서 알아보도록 합시다.   Test 1 에서는 어떤일이 일어나는가  Person person = personRepository.save(JOHN);   단 한줄입니다   save 메소드의 내부 코드를 간단하게 살펴보면 다음과 같습니다 (분량상 몇줄 생략)   @Transactional public &lt;S extends T&gt; S save(S entity) {     if (entityInformation.isNew(entity)) {         entityManager.persist(entity);         return entity;     } else {         return entityManager.merge(entity);     } }   아무것도 없는 상태에서 테스트 1을 수행했기 때문에,   영속성 컨텍스트에 해당 엔티티가 존재하는지 확인하는 isNew 의 결과에 따라서 분기가 갈립니다.   간단하게 isNew메소드의 구현을 보면 아래와 같습니다   public boolean isNew(T entity) {     ID id = getId(entity);     Class&lt;ID&gt; idType = getIdType();          if (!idType.isPrimitive()) {         return id == null;     }          if (id instanceof Number) {         return ((Number) id).longValue() == 0L;     } }   id의 타입이 원시타입이 아니라면 null일 때 true 입니다.  따라서 isNew는 true를 반환합니다   (Long은 wrapper 클래스이기때문에 원시타입이 아닙니다.)   이후 entityManager.persist 메소드 호출을 통해서 해당 엔티티는 영속성 컨텍스트에 등록됩니다. 인자로 넘긴 값을 그대로 반환하기 때문에 당연히 첫 assert는 성공합니다   영속성 컨텍스트와 롤백   첫번째 테스트가 종료되었습니다. 첫번째 테스트가 롤백되면, 데이터베이스에 저장되어있는 JOHN 엔티티는 사라질 것입니다. 마찬가지로, 영속성 컨텍스트 또한 초기화되면서 내부의 엔티티들은 detached 상태로 전환됩니다     transaction rollback causes all pre-existing managed instances and removed instances [31] to become detached  [JSR-000317 Persistence Specification for Eval 2.0 Eval]    간단하게 em.contains(JOHN) 과 personRepository.find(JOHN)을 통해서 확인할 수 있고,  예상대로 둘다 false를 반환합니다.   하지만 id는 어떨까요?  Test2의 첫번째 줄에 JOHN.getId()를 하면 null 이 아닌 1이 출력되는것을 확인할 수 있습니다.  트랜잭션이 롤백되더라도 in-memory로 올라가있는 static 객체인 JOHN에 추가된 id는 회수되지 않는것입니다.  그리고 이게 두번째 테스트가 실패하는 원인입니다.   다시 save로 돌아가봅시다. 마찬가지로 isNew 까지 들어가는데, 이번에는 id 가 null이 아니기 때문에 em.merge()를 호출합니다.  em.merge는 반환할 때 새로운 영속상태의 엔티티를 생성해서 반환합니다.   (주의:전달된 인자가 영속상태로 관리되는것이 아니라, 영속상태로 관리되는 새로운 객체를 반환) (em.contains(JOHN)을 해본다면 false가 출력됩니다)   즉, JOHN과는 전혀 다른, 영속상태로 관리되는 객체를 의미하는것입니다.  따라서 assert문은 실패하게 됩니다.   테스트간 엔티티를 공유하는것이 문제가 될 수 있는 시나리오였습니다.  이상입니다.   부록 - 왜 id는 트랜잭션이 롤백되더라도 회수되지 않는가?  id는 왜 롤백되더라도 원래 상태로 복구되지 않습니다.  즉 id에 대한 값 부여는 트랜잭션과 별도로 일어나는 작업입니다.  왜 그럴까요?  만약 진행중인 트랜잭션이 끝나지 않고 5분동안 락을 소유하게 된다면 해당 테이블에 값을 레코드를 추가하고 싶은 다른 트랜잭션들의 작업이 모두 막히기 때문입니다.     from StackOverflow, Vlad Mihalcea   ","categories": ["JPA"],
        "tags": ["JPA"],
        "url": "/jpa/persistance2/",
        "teaser": null
      },{
        "title": "인터페이스 분리 원칙에 대해",
        "excerpt":"다 알고 있는 사실     어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다  자신이 사용하는 메서드에만 의존해야 한다    매번 나오는 설명입니다.  보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.   interface Person { \tpublic void work(); \tpublic void eat(); \tpublic void play(); }  class SomePerson implements Person{ \tpublic void work() {         ... \t} \tpublic void eat() {         ... \t} \tpublic void play() { \t\t... \t} }  class VeganPerson implements Person{ \tpublic void work() {         ... \t}  \tpublic void eat() {         ... \t} \tpublic void play() { \t\t... \t} }  하지만 eat 메소드가 필요 없는 Worker가 등장할 경우  예외 처리를 하거나 의미없는 반환값 등으로 구현을 해야합니다.   따라서   interface Workable { \tpublic void work(); }  interface Feedable{ \tpublic void eat(); }  interface Playable{ \tpublic void eat(); }  class Person implements Workable, Feedable, Playable{ \tpublic void work() { \t\t... \t}  \tpublic void eat() { \t\t... \t}  \tpublic void play() { \t\t... \t} }   이렇게 짜라고 알려져 있습니다.   근데 왜?  ISP를 준수하면 얻는것이 무엇인가?      변경에 대해서 유연한 것 ?   불필요한 책임 제거 ?   확장성 향상?   이것들은 SRP나 다형성에 대한 것들이지, ISP와는 거리가 있다고 생각합니다.   의존하는 모듈을 생각하라  앞서 언급된 설명은 클래스에 구현에 초점이 맞춰져 있습니다.  하지만 ISP의 의의는 의존관계에 있다고 생각합니다.  클래스의 의존관계의 측면에서 ISP를 준수하지 않는 경우를 살펴보도록 합시다.      하나의 클래스에 모듈 A,B,C에 필요한 메소드들이 모두 선언되어있습니다  여기서 문제는 모듈 A가 자신이 사용하지 않는 메소드 (2,3,5,6)을 호출하는것을 막지 못한다는것입니다.  모듈 B와 C도 마찬가지입니다.   다시 이전 코드 예시로 돌아가겠습니다.  ISP 를 준수하지 않은 Worker 인터페이스를 의존하는 모듈을 가정해봅시다.   class WorkPlace { \tprivate List&lt;Person&gt; workers;  \tpublic void addWorker(Person worker) { \t\tworkers.add(worker); \t}  \tpublic void allWork() { \t\tfor(Person worker : workers) { \t\t\tworker.work(); \t\t}  \t\t//troll \t\tworker.play(); \t} }   WorkPlace 클래스 내부에서 Worker을 직접적으로 의존하게되면 다른 메소드를 호출하는것이 가능해져버립니다.   이 문제를 해결하는 방법은 두가지가 존재합니다.   소유 모델    class Person { \tprivate Workable work; \tprivate Playable play; \tprivate Eatable eat; }  이후 각 모듈들은 Person이 소유하는 내부 객체만을 바라보면서 소통할 수 있습니다.   인터페이스 모델    interface Person extends Workable, Playable, Eatable { \t }  마찬가지로 외부 모듈들은 Workable, Playable, Eatable을 골라서 협력하는것이 가능합니다.   결과  위 두 방법을 사용하여 인터페이스에 의존한다면 컴파일 타임에 막을 수 있습니다.   class WorkPlace { \tprivate List&lt;IWork&gt; workers;  \tpublic void addWorker(Workable worker) { \t\tworkers.add(worker); \t}  \tpublic void allWork() { \t\tfor(Workable worker : workers) { \t\t\tworker.work(); \t\t}  \t\t//doesn't compile \t\tworker.play(); \t} }   즉 ISP를 만족시킨다면 인터페이스에 대한 접근권한을 컴파일 시간에 타입으로 막을 수 있는 것입니다.   감사합니다.   Credits  모든 내용은 유튜브 코드스피츠 채널 을 참고하였습니다  ","categories": ["객체지향"],
        "tags": ["객체지향"],
        "url": "/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/isp1/",
        "teaser": null
      },{
        "title": "스프링 코드 아키텍처",
        "excerpt":"작성자 : Claycat   개요   여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?   이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다.  프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요.  결정 과정에 대해서 소개해 보려고 합니다.   해당 프로젝트의 Github 여기 입니다.   서론   이전에 진행했던 프로젝트들은 전통적인 Layered Architecture로 이루어졌습니다.      일반적으로 Controller, Service, Repository 세개의 레이어로 구성되어있습니다. Controller에서는 Service에 의존하고, Service에서는 Repository에 의존하는 방식입니다.   조금 더 구체적인 예시를 들면 다음과 같습니다.      해당 방식은 소규모의 프로젝트에서는 문제가 없었지만,  다양한 유틸리티 메소드와 비즈니스 로직이 많아지고, API 엔드포인트들이 많아질수록 서비스단의 코드가 비대해졌습니다.  서비스 코드가 몇백줄을 넘어가면서 유지보수성은 떨어지고 가독성 또한 낮아졌습니다.   원인   이 문제의 원인은 컨트롤러 - 서비스간의 1:1 관계 때문이라고 분석했습니다. 위 Member 예제처럼 MemberController - MemberService로 연관되어있는 경우입니다.  이 경우, MemberService는 MemberController의 모든 엔드포인트를 메소드로 구현해야 합니다.  Member에 대한 모든 비즈니스 로직을 포함할 수 밖에 없고, 거대한 테스트 코드는 덤입니다.   저희는 해당 도메인을 단 하나의 서비스 객체로 나타내는 구조는 거대한 객체를 유발하고,  가독성과 유지보수성이 떨어지며,  객체지향적으로도 너무 많은 책임을 갖는 좋지 않은 구조라고 판단하였습니다.   대안   해당 문제를 어떻게 해결할 수 있을지 회의를 하였고, 몇가지 제안들이 있었습니다.           CrudService              ✋ 비대한 서비스 코드를 줄일 수 있도록 CRUD관련 엔드포인트들만 별도로 처리하는 서비스 객체를 사용하자!                Hexagonal Architecture &amp; Clean Architecture              ✋ 익숙한 계층 아키텍처 대신 새로운 아키텍처를 도입해서 사용하자!                DDD의 아이디어 채용 - UseCase에 중점을 두자              ✋ 꼭 하나의 서비스가 여러개의 엔드포인트를 처리해야 할까?  하나의 엔드포인트에 대한 하나의 서비스(유즈케이스)로서 대응하는건 어떨까?           논의           CrudService              🙆 비대한 서비스 코드의 부담을 일부분 덜어줄 수 있다는 것은 동의.                    🙅 하지만 결국 본질적인 문제를 해결하는것은 아니다.           🙅 CRUD이외의 엔드포인트가 다수 추가된다면 결국 비대해지는것은 마찬가지                                Hexagonal &amp; Clean Architecture              기존 계층구조로 구성된 코드를 모두 뒤엎어야 함                    🙅 참고할 수 있는 정석적인 자료가 부재하며, 참고자료마다 구현방식이 모두 다름                       🙆 Ports &amp; Adapter를 통해 외부 입력과 출력에 대해서 독립성을 확보할 수 있다                    🙅 in/out에 대한 port 및 adapter를 모두 작성해야 하는 불편함이 존재           🙅 사이드 프로젝트의 규모상 웹 요청방식은 HTTP이외가 추가되지 않을 것이며,  마찬가지로 영속성 툴 또한 메인 DB (MySQL)에서 추가되지 않을 것인데, 오버엔지니어링이 아닐까                                UseCase 중심             🙆 익숙한 편이며, 서비스를 잘게 쪼갤 수 있다.       🙅 결국 모든 엔드포인트에 대해서 대응하는 유즈케이스 객체가 만들어질텐데, 너무 많아지지 않을까?                    🙆 어차피 작업중인 유즈케이스만 보게 될 것           🙆 동시에 여러 유즈케이스를 보는 상황이 온다면 의존성 문제가 생긴게 아닐까                           결론   논의 결과, 저희는 UseCase를 중심으로 한, 세분화된 서비스 객체의 계층구조로 결정하였습니다.   결론은 다음과 같습니다.           컨트롤러는 기존과 동일한 역할을 수행하고, 도메인별로 분리합니다.              API 엔드포인트 상                    /members/** -&gt; MemberController           /ticketings/** -&gt; TicketingController                                기존 서비스를 메소드별로 UseCase로 나누어 별도의 객체로 분리합니다.             MemberService 하위의                    memberService.login -&gt; LoginUseCase           memberService.register -&gt; RegisterUseCase           memberService.logout -&gt; LogoutUseCase                           코드를 살펴보면 다음과 같습니다.   //편의상 주입 생략  @RestController @RequestMapping(\"/members\") public class MemberController {  \t@PostMapping(\"/register\") \tpublic ApiResponse&lt;MemberRegisterResponseDto&gt; registerMember( \t\tfinal @Valid @RequestBody MemberRegisterRequestDto registerMemberDto) { \t\treturn ApiResponse.wrap( \t\t\tMemberRegisterResponseDto.toDto(memberRegisterUseCase.register(MemberRegisterCommandDto.builder() \t\t\t\t.email(registerMemberDto.getEmail()) \t\t\t\t.isSeller(registerMemberDto.getIsSeller()) \t\t\t\t.build() \t\t\t)) \t\t); \t}  \t@PostMapping(path = \"/password-reset/mail\") \tpublic ResponseEntity sendPasswordChangeEmail() { \t\tvar email = securityContextHelper.getEmailInToken(); \t\tsendPasswordChangeEmailUseCase.sendEmail( \t\t\tSendPwdChangeEmailCommandDto.builder().email(email).build()); \t\treturn ResponseEntity.ok().build(); \t}  \t@PostMapping(path = \"/{memberId}/points\") \tpublic ResponseEntity&lt;ApiResponse&lt;ChargePointResponseDto&gt;&gt; chargePoint(@PathVariable String memberId, \t\t@Valid @RequestBody ChargePointRequestDto request) { \t\tvar email = securityContextHelper.getEmailInToken(); \t\tvar totalPoint = chargeMemberPointUseCase.chargePoint(request.convertToCommandDto(memberId, email)) \t\t\t.getTotalPoint(); \t\tvar result = ChargePointResponseDto.builder().totalPoint(totalPoint).build(); \t\treturn ResponseEntity.status(HttpStatus.OK).body(ApiResponse.wrap(result)); \t} }   재사용성과 의존성   해당 방식을 논의하던 중, 여러 유즈케이스에서 공통적으로 의존하는 로직이나 모듈에 대한 지적이 있었습니다.  공통적인 로직을 처리할 때는 ***Service라는 네이밍으로 적절한 추상화와 객체지향적 센스를 발휘하여 사용하기로 정하였습니다.   예시를 살펴보면 다음과 같습니다.   구매자의 “구매목록”을 담당하는 Purchase 도메인 내부의 생성 및 삭제 유즈 케이스입니다.   @Service public class CreatePurchaseUseCase {  \t@Transactional \tpublic CreatePurchaseResultDto createPurchase(CreatePurchaseCommandDto command) {          //PurchaseService \t\tpurchaseService.validateTicketingSalePeriod(ticketingId, command.getCommandCreatedAt());  \t\tvar newPurchase = purchaseRepository.save(Purchase.builder().member(member).build()); \t\tvar tickets = ticketRepository.findByTicketingIdAndPurchaseIsNullOrderById( \t\t\tticketingId, Limit.of(count));  \t\tif (tickets.size() &lt; count) { \t\t\tthrow new NotEnoughTicketException(); \t\t}  \t\ttickets.forEach(ticket -&gt; { \t\t\tticket.setPurchase(newPurchase); \t\t});  \t\treturn CreatePurchaseResultDto.builder() \t\t\t.purchaseId(newPurchase.getId()) \t\t\t.createdAt(newPurchase.getCreatedAt()) \t\t\t.build(); \t} }   @Service public class DeletePurchaseTicketsUseCase {  \t@Transactional \tpublic void deletePurchaseTickets(DeletePurchaseTicketsCommandDto command) { \t\tvar purchase = purchaseRepository.findById(command.getPurchaseId()).orElseThrow( \t\t\tPurchaseNotFoundException::new); \t\tvar ticketsUnderPurchase = purchaseService.findTicketsUnderPurchase(purchase.getId()); \t\tvar ticketsToRefund = ticketRepository.findAllById(command.getTicketIds()); \t\tvar ticketing = ticketsUnderPurchase.getFirst().getTicketing();          //PurchaseService \t\tpurchaseService.validatePurchaseOwnership(purchase.getId(), command.getMemberEmail()); \t\tpurchaseService.validateTicketingSalePeriod(ticketing.getId(), command.getCommandCreatedAt());  \t\tvar ticketIdUnderPurchase = ticketsUnderPurchase.stream().map(Ticket::getId).toList(); \t\tAtomicInteger numOfDeletedTicket = new AtomicInteger(); \t\tticketsToRefund.forEach(ticket -&gt; { \t\t\tif (ticketIdUnderPurchase.contains(ticket.getId())) { \t\t\t\tticket.setPurchase(null); \t\t\t\tnumOfDeletedTicket.getAndIncrement(); \t\t\t} \t\t}); \t\tif (numOfDeletedTicket.get() == ticketsUnderPurchase.size()) { \t\t\tpurchaseRepository.delete(purchase); \t\t} \t} }    두가지 유즈케이스 모두 “구매”에 대한 Validation을 하는 공통 로직에 의존하고 있기 때문에  해당 로직은 PurchaseService에 위임하였습니다.   다이어그램으로 살펴보면 다음과 같습니다.      이를 통해 공통 로직과 의존도를 분리할 수 있었습니다.   후기   개인적으로 더이상 거대한 Service 객체를 보지 않아도 되는 면에서 가독성만큼은 훨씬 낫다고 생각합니다. 하나의 유즈케이스에 대해서만 집중해도 되니 유틸리티 메소드에 대한 의존성 관리도 쾌적해졌다고 느꼈습니다.  이전에 사용하던 계층 구조와 선택하라고 한다면 분명 현재를 고를 것입니다.  다만 우려되거나 아쉬운 부분 또한 존재합니다.   특히 우려되는 점은 서비스에 대한 오염입니다.  적절한 책임의 분리를 하지 않고 모든 유틸리티 메소드들을 밀어넣는 용도로 XXXService를 사용한다면  결국 재사용성이 떨어지는 거대객체가 될 확률이 높습니다.   이 글을 작성하면서 보니, 위 언급된 이미지에서의 PurchaseService 또한 Validation과 Find의 유틸리티 책임이 혼합되어있습니다.  PurchaseValidationService와 PurchaseFindService로 쪼개는게 더 적절할 수도 있습니다.   아쉬운 부분은 Hexagonal 과 Clean Architecture, Domain Driven Design등에 대해서 조금 더 깊은 이해를 했거나  경험이 있었다면 더 좋은 아키텍처가 있을 수도 있다는 것이었습니다.  해당 부분은 사이드 프로젝트를 마무리한다면 깊게 한번 다시 탐구해보도록 하겠습니다.   감사합니다.  ","categories": ["Tiketeer"],
        "tags": ["spring","tiketeer"],
        "url": "/tiketeer/architecture/",
        "teaser": null
      },{
        "title": "티케팅 시스템 구현에서의 동시성 문제 : 원인",
        "excerpt":"개요  ","categories": ["Tiketeer"],
        "tags": ["spring","concurrency","tiketeer"],
        "url": "/tiketeer/concurrency/",
        "teaser": null
      }]
