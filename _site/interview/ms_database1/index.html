<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>CS 면접대비 - 데이터베이스 : Claycat</title>
<meta name="description" content="데이터베이스 키에 대해서 설명해주세요            Candidate Key                    Unique 식별           최소 속성                       Foreign Key                    다른 테이블의 Primary Key                       Primary Key                    Candidate Key중 선택된 Main Key                       Alternate Key                    Candidate Key - Primary Key                       Super Key                    Unique 식별하지만 최소 속성은 만족 못하는 키                          데이터베이스를 왜 사용할까요?            데이터베이스 이전에는 파일시스템을 사용하여 데이터를 식별하였습니다. 디스크 IO는 느리고, 실제 어플리케이션은 랜덤 IO를 많이 발생시킵니다. 이것을 해결하기 위해서 랜덤 IO를 순차 IO로 바꿔서 실행하는걸 통해 더 성능적 이득이 있습니다.          트랜잭션            트랜잭션은 무엇인가요? 왜 필요한가요?                    데이터베이스에서 논리적인 작업의 단위입니다.                                트랜잭션 특징                     원자성(Atomicity) : all or nothing           일관성(Consistancy) : 항상 동일한 결과           독립성(Isolation) : 다른 트랜잭션이 끼어들 수 없다           지속성(Durability) : 트랜잭션의 결과는 영구적으로 반영                       트랜잭션 격리수준                    _트랜잭션 격리수준이 왜 필요한가요? _                            트랜잭션은 ACID 원칙을 지켜야 하지만, 완벽하게 지키는 형태는 동시적인 요청에 대한 처리량이 떨어지게 됩니다. 따라서 데이터베이스는 애플리케이션 개발자가 본인들의 환경에 맞게 트레이드오프를 고려하여 선택할 수 있도록 격리레벨을 만들어두었습니다.                                    어떤 트레이드오프인가요?                                            동시적 처리량을 늘릴수록 이상현상이 더 많이 발생합니다.                                                    대표적인 이상현상을 말씀드리면 아래가 있습니다.                                                            DIRTY READ : 트랜잭션 실행도중 다른 트랜잭션의 업데이트에 의해 수정된 데이터를 읽는것                               PHANTOM READ : 동일한 쿼리에 대해서 두번째 쿼리에서 없던 결과가 나오는것                               NON REPEATABLE READ : 트랜잭션 실행도중 두번째 읽었을 때 다른 값이 나오는것                                                                                                                                                                   격리수준이 이 문제를 어떻게 해결해주나요?                                            Serializable : 모든 트랜잭션이 순차적으로 실행되도록 합니다 어떠한 문제도 일어나지 않습니다.                       Repeatable Read: MySQL의 기본 설정입니다. 변경 전 레코드를 언두 공간에 백업해두고 앞서 처리된 트랜잭션에 대해서는 언두 공간의 값을 읽게 합니다. 트랜잭션이 앞서 처리되었는지는 트랜잭션마다 번호를 부여하여 판단합니다. 일반적인 Phantom Read 또한 이후 트랜잭션 번호를 가진 언두로그를 봐서 무시하면 되지만 SELECT FOR UPDATE와 같이 같이 관여할 경우, 락은 언두로그가 아닌 테이블값을 읽기 때문에 Phantom Read가 발생할 수 있습니다.                       Read Commited : Commit된 데이터만 읽을 수 있도록 하는 설정입니다. Commit 된 데이터를 읽을 경우 Non Repeatable Read가 발생할 수 있습니다.                       Read Uncommited : Commit 되지 않은 데이터도 읽을 수 있도록 하는것. 모든 이상현상 발생.                                                                                                                           정규화            정규화란 무엇인가요? 왜 필요한가요?                    정규화란 데이터베이스 테이블들의 관계에서 중복을 최소화시키는 방법입니다.                       역정규화?                    테이블에 대한 조인이 성능적으로 문제가 되는 경우(경로가 멀어서)           조회에 대한 처리성능이 중요하다고 판단된다면                           인덱스            인덱스가 무엇인가요? 왜 필요한가요?                    데이터베이스는 랜덤 IO 엑세스와의 싸움입니다.   추가적인 쓰기작업과 저장공간을 사용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조를 의미합니다.           어떤 자료구조인가요?                            일반적으로는 B+ 트리를 이용합니다.                                    왜 B+ 트리를 이용할까요?                                            B+ 트리는 Leaf Node간 연결이 되어있기때문에                                                    FullScan과 Range Scan에 유리합니다.                                                                                                                                                                       인덱스의 성능 또는 고려해야할 사항?                    WHERE 절에 자주 사용되는 열           SELECT 절에 자주 등장하는 칼럼           JOIN에 자주 사용되는 열           데이터 중복도가 높은 열은 효과가 없음                            남성/여성                                   WHERE 절을 변형하면 인덱스를 안타는 이유                            결국 시작점을 알 수 없기 때문임 LIKE 또는 SUBSTR                                   복합 인덱스를 구성할 때 칼럼의 순서를 고려하는 기준                            분포도는 의미가 없다                                    연산자가 “=” 가 아닐 수 있기 때문                                               연산자를 최우선적으로 고려하라                                    분포도가 좋더라도 연산자가 선분조건이면 앞에 두는게 안좋을 수 있다는것">



<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="Claycat">
<meta property="og:title" content="CS 면접대비 - 데이터베이스">
<meta property="og:url" content="http://localhost:4000/interview/ms_database1/">


  <meta property="og:description" content="데이터베이스 키에 대해서 설명해주세요            Candidate Key                    Unique 식별           최소 속성                       Foreign Key                    다른 테이블의 Primary Key                       Primary Key                    Candidate Key중 선택된 Main Key                       Alternate Key                    Candidate Key - Primary Key                       Super Key                    Unique 식별하지만 최소 속성은 만족 못하는 키                          데이터베이스를 왜 사용할까요?            데이터베이스 이전에는 파일시스템을 사용하여 데이터를 식별하였습니다. 디스크 IO는 느리고, 실제 어플리케이션은 랜덤 IO를 많이 발생시킵니다. 이것을 해결하기 위해서 랜덤 IO를 순차 IO로 바꿔서 실행하는걸 통해 더 성능적 이득이 있습니다.          트랜잭션            트랜잭션은 무엇인가요? 왜 필요한가요?                    데이터베이스에서 논리적인 작업의 단위입니다.                                트랜잭션 특징                     원자성(Atomicity) : all or nothing           일관성(Consistancy) : 항상 동일한 결과           독립성(Isolation) : 다른 트랜잭션이 끼어들 수 없다           지속성(Durability) : 트랜잭션의 결과는 영구적으로 반영                       트랜잭션 격리수준                    _트랜잭션 격리수준이 왜 필요한가요? _                            트랜잭션은 ACID 원칙을 지켜야 하지만, 완벽하게 지키는 형태는 동시적인 요청에 대한 처리량이 떨어지게 됩니다. 따라서 데이터베이스는 애플리케이션 개발자가 본인들의 환경에 맞게 트레이드오프를 고려하여 선택할 수 있도록 격리레벨을 만들어두었습니다.                                    어떤 트레이드오프인가요?                                            동시적 처리량을 늘릴수록 이상현상이 더 많이 발생합니다.                                                    대표적인 이상현상을 말씀드리면 아래가 있습니다.                                                            DIRTY READ : 트랜잭션 실행도중 다른 트랜잭션의 업데이트에 의해 수정된 데이터를 읽는것                               PHANTOM READ : 동일한 쿼리에 대해서 두번째 쿼리에서 없던 결과가 나오는것                               NON REPEATABLE READ : 트랜잭션 실행도중 두번째 읽었을 때 다른 값이 나오는것                                                                                                                                                                   격리수준이 이 문제를 어떻게 해결해주나요?                                            Serializable : 모든 트랜잭션이 순차적으로 실행되도록 합니다 어떠한 문제도 일어나지 않습니다.                       Repeatable Read: MySQL의 기본 설정입니다. 변경 전 레코드를 언두 공간에 백업해두고 앞서 처리된 트랜잭션에 대해서는 언두 공간의 값을 읽게 합니다. 트랜잭션이 앞서 처리되었는지는 트랜잭션마다 번호를 부여하여 판단합니다. 일반적인 Phantom Read 또한 이후 트랜잭션 번호를 가진 언두로그를 봐서 무시하면 되지만 SELECT FOR UPDATE와 같이 같이 관여할 경우, 락은 언두로그가 아닌 테이블값을 읽기 때문에 Phantom Read가 발생할 수 있습니다.                       Read Commited : Commit된 데이터만 읽을 수 있도록 하는 설정입니다. Commit 된 데이터를 읽을 경우 Non Repeatable Read가 발생할 수 있습니다.                       Read Uncommited : Commit 되지 않은 데이터도 읽을 수 있도록 하는것. 모든 이상현상 발생.                                                                                                                           정규화            정규화란 무엇인가요? 왜 필요한가요?                    정규화란 데이터베이스 테이블들의 관계에서 중복을 최소화시키는 방법입니다.                       역정규화?                    테이블에 대한 조인이 성능적으로 문제가 되는 경우(경로가 멀어서)           조회에 대한 처리성능이 중요하다고 판단된다면                           인덱스            인덱스가 무엇인가요? 왜 필요한가요?                    데이터베이스는 랜덤 IO 엑세스와의 싸움입니다.   추가적인 쓰기작업과 저장공간을 사용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조를 의미합니다.           어떤 자료구조인가요?                            일반적으로는 B+ 트리를 이용합니다.                                    왜 B+ 트리를 이용할까요?                                            B+ 트리는 Leaf Node간 연결이 되어있기때문에                                                    FullScan과 Range Scan에 유리합니다.                                                                                                                                                                       인덱스의 성능 또는 고려해야할 사항?                    WHERE 절에 자주 사용되는 열           SELECT 절에 자주 등장하는 칼럼           JOIN에 자주 사용되는 열           데이터 중복도가 높은 열은 효과가 없음                            남성/여성                                   WHERE 절을 변형하면 인덱스를 안타는 이유                            결국 시작점을 알 수 없기 때문임 LIKE 또는 SUBSTR                                   복합 인덱스를 구성할 때 칼럼의 순서를 고려하는 기준                            분포도는 의미가 없다                                    연산자가 “=” 가 아닐 수 있기 때문                                               연산자를 최우선적으로 고려하라                                    분포도가 좋더라도 연산자가 선분조건이면 앞에 두는게 안좋을 수 있다는것">







  <meta property="article:published_time" content="2024-01-24T12:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/interview/ms_database1/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Claycat",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Claycat Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->



<link
  rel="apple-touch-icon"
  sizes="180x180"
  href="/assets/images/favicons/apple-touch-icon.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="32x32"
  href="/assets/images/favicons/favicon-32x32.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="16x16"
  href="/assets/images/favicons/favicon-16x16.png"
/>

<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico" />
<meta name="apple-mobile-web-app-title" content="Claycat" />
<meta name="application-name" content="Claycat" />
<meta name="msapplication-TileColor" content="#da532c" />
<meta
  name="msapplication-config"
  content="/assets/images/favicons/browserconfig.xml"
/>
<meta name="theme-color" content="#ffffff" />

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Claycat
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
         

<div id="main" role="main">
  


  <article
    class="page h-entry"
    itemscope
    itemtype="https://schema.org/CreativeWork"
  >
    <meta
      itemprop="headline"
      content="CS 면접대비 - 데이터베이스"
    /> <meta
      itemprop="description"
      content="데이터베이스 키에 대해서 설명해주세요          Candidate Key                  Unique 식별          최소 속성                    Foreign Key                  다른 테이블의 Primary Key                    Primary Key                  Candidate Key중 선택된 Main Key                    Alternate Key                  Candidate Key - Primary Key                    Super Key                  Unique 식별하지만 최소 속성은 만족 못하는 키                    데이터베이스를 왜 사용할까요?          데이터베이스 이전에는 파일시스템을 사용하여 데이터를 식별하였습니다.디스크 IO는 느리고, 실제 어플리케이션은 랜덤 IO를 많이 발생시킵니다.이것을 해결하기 위해서 랜덤 IO를 순차 IO로 바꿔서 실행하는걸 통해 더 성능적 이득이 있습니다.      트랜잭션          트랜잭션은 무엇인가요? 왜 필요한가요?                  데이터베이스에서 논리적인 작업의 단위입니다.                            트랜잭션 특징                  원자성(Atomicity) : all or nothing          일관성(Consistancy) : 항상 동일한 결과          독립성(Isolation) : 다른 트랜잭션이 끼어들 수 없다          지속성(Durability) : 트랜잭션의 결과는 영구적으로 반영                    트랜잭션 격리수준                  _트랜잭션 격리수준이 왜 필요한가요? _                          트랜잭션은 ACID 원칙을 지켜야 하지만, 완벽하게 지키는 형태는 동시적인 요청에 대한 처리량이 떨어지게 됩니다.따라서 데이터베이스는 애플리케이션 개발자가 본인들의 환경에 맞게 트레이드오프를 고려하여 선택할 수 있도록 격리레벨을 만들어두었습니다.                                  어떤 트레이드오프인가요?                                          동시적 처리량을 늘릴수록 이상현상이 더 많이 발생합니다.                                                  대표적인 이상현상을 말씀드리면 아래가 있습니다.                                                          DIRTY READ : 트랜잭션 실행도중 다른 트랜잭션의 업데이트에 의해 수정된 데이터를 읽는것                              PHANTOM READ : 동일한 쿼리에 대해서 두번째 쿼리에서 없던 결과가 나오는것                              NON REPEATABLE READ : 트랜잭션 실행도중 두번째 읽었을 때 다른 값이 나오는것                                                                                                                                                            격리수준이 이 문제를 어떻게 해결해주나요?                                          Serializable : 모든 트랜잭션이 순차적으로 실행되도록 합니다 어떠한 문제도 일어나지 않습니다.                      Repeatable Read: MySQL의 기본 설정입니다.변경 전 레코드를 언두 공간에 백업해두고 앞서 처리된 트랜잭션에 대해서는 언두 공간의 값을 읽게 합니다.트랜잭션이 앞서 처리되었는지는 트랜잭션마다 번호를 부여하여 판단합니다.일반적인 Phantom Read 또한 이후 트랜잭션 번호를 가진 언두로그를 봐서 무시하면 되지만SELECT FOR UPDATE와 같이 같이 관여할 경우, 락은 언두로그가 아닌 테이블값을 읽기 때문에Phantom Read가 발생할 수 있습니다.                      Read Commited : Commit된 데이터만 읽을 수 있도록 하는 설정입니다.Commit 된 데이터를 읽을 경우 Non Repeatable Read가 발생할 수 있습니다.                      Read Uncommited : Commit 되지 않은 데이터도 읽을 수 있도록 하는것. 모든 이상현상 발생.                                                                                                              정규화          정규화란 무엇인가요? 왜 필요한가요?                  정규화란 데이터베이스 테이블들의 관계에서 중복을 최소화시키는 방법입니다.                    역정규화?                  테이블에 대한 조인이 성능적으로 문제가 되는 경우(경로가 멀어서)          조회에 대한 처리성능이 중요하다고 판단된다면                    인덱스          인덱스가 무엇인가요? 왜 필요한가요?                  데이터베이스는 랜덤 IO 엑세스와의 싸움입니다.  추가적인 쓰기작업과 저장공간을 사용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조를 의미합니다.          어떤 자료구조인가요?                          일반적으로는 B+ 트리를 이용합니다.                                  왜 B+ 트리를 이용할까요?                                          B+ 트리는 Leaf Node간 연결이 되어있기때문에                                                  FullScan과 Range Scan에 유리합니다.                                                                                                                                                            인덱스의 성능 또는 고려해야할 사항?                  WHERE 절에 자주 사용되는 열          SELECT 절에 자주 등장하는 칼럼          JOIN에 자주 사용되는 열          데이터 중복도가 높은 열은 효과가 없음                          남성/여성                                WHERE 절을 변형하면 인덱스를 안타는 이유                          결국 시작점을 알 수 없기 때문임 LIKE 또는 SUBSTR                                복합 인덱스를 구성할 때 칼럼의 순서를 고려하는 기준                          분포도는 의미가 없다                                  연산자가 “=” 가 아닐 수 있기 때문                                            연산자를 최우선적으로 고려하라                                  분포도가 좋더라도 연산자가 선분조건이면 앞에 두는게 안좋을 수 있다는것                                                                        "
    /> <meta
      itemprop="datePublished"
      content="2024-01-24T12:00:00+09:00"
    /> 

    <div class="page__inner-wrap">
      
      <header>
        
        <h1 id="page-title" class="page__title" itemprop="headline">
          <p>CS 면접대비 - 데이터베이스</p>

        </h1>
         
      </header>
      

      <section class="page__content e-content" itemprop="text">
         <details><summary>데이터베이스 키에 대해서 설명해주세요</summary><div>
    <ol>
      <li>Candidate Key
        <ol>
          <li>Unique 식별</li>
          <li>최소 속성</li>
        </ol>
      </li>
      <li>Foreign Key
        <ol>
          <li>다른 테이블의 Primary Key</li>
        </ol>
      </li>
      <li>Primary Key
        <ol>
          <li>Candidate Key중 선택된 Main Key</li>
        </ol>
      </li>
      <li>Alternate Key
        <ol>
          <li>Candidate Key - Primary Key</li>
        </ol>
      </li>
      <li>Super Key
        <ol>
          <li>Unique 식별하지만 최소 속성은 만족 못하는 키</li>
        </ol>
      </li>
    </ol>
  </div></details>

<details><summary>데이터베이스를 왜 사용할까요?</summary><div>
    <ul>
      <li>데이터베이스 이전에는 파일시스템을 사용하여 데이터를 식별하였습니다.<br />
디스크 IO는 느리고, 실제 어플리케이션은 랜덤 IO를 많이 발생시킵니다.<br />
이것을 해결하기 위해서 랜덤 IO를 순차 IO로 바꿔서 실행하는걸 통해 더 성능적 이득이 있습니다.</li>
    </ul>
  </div></details>

<details><summary>트랜잭션</summary><div>
    <ul>
      <li><strong><em>트랜잭션은 무엇인가요? 왜 필요한가요?</em></strong>
        <ul>
          <li>데이터베이스에서 논리적인 작업의 단위입니다.</li>
        </ul>
      </li>
      <li>
        <p>트랜잭션 특징</p>

        <ul>
          <li>원자성(Atomicity) : all or nothing</li>
          <li>일관성(Consistancy) : 항상 동일한 결과</li>
          <li>독립성(Isolation) : 다른 트랜잭션이 끼어들 수 없다</li>
          <li>지속성(Durability) : 트랜잭션의 결과는 영구적으로 반영</li>
        </ul>
      </li>
      <li>트랜잭션 격리수준
        <ul>
          <li><strong>_트랜잭션 격리수준이 왜 필요한가요? _</strong>
            <ul>
              <li>트랜잭션은 ACID 원칙을 지켜야 하지만, 완벽하게 지키는 형태는 동시적인 요청에 대한 처리량이 떨어지게 됩니다.
따라서 데이터베이스는 애플리케이션 개발자가 본인들의 환경에 맞게 트레이드오프를 고려하여 선택할 수 있도록 격리레벨을 만들어두었습니다.
                <ul>
                  <li><strong><em>어떤 트레이드오프인가요?</em></strong>
                    <ul>
                      <li>동시적 처리량을 늘릴수록 이상현상이 더 많이 발생합니다.
                        <ul>
                          <li>대표적인 이상현상을 말씀드리면 아래가 있습니다.
                            <ul>
                              <li>DIRTY READ : 트랜잭션 실행도중 다른 트랜잭션의 업데이트에 의해 수정된 데이터를 읽는것</li>
                              <li>PHANTOM READ : 동일한 쿼리에 대해서 두번째 쿼리에서 없던 결과가 나오는것</li>
                              <li>NON REPEATABLE READ : 트랜잭션 실행도중 두번째 읽었을 때 다른 값이 나오는것</li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li><strong><em>격리수준이 이 문제를 어떻게 해결해주나요?</em></strong>
                    <ul>
                      <li>Serializable : 모든 트랜잭션이 순차적으로 실행되도록 합니다 어떠한 문제도 일어나지 않습니다.</li>
                      <li>Repeatable Read: MySQL의 기본 설정입니다.<br />
변경 전 레코드를 언두 공간에 백업해두고 앞서 처리된 트랜잭션에 대해서는 언두 공간의 값을 읽게 합니다.
트랜잭션이 앞서 처리되었는지는 트랜잭션마다 번호를 부여하여 판단합니다.
일반적인 Phantom Read 또한 이후 트랜잭션 번호를 가진 언두로그를 봐서 무시하면 되지만
SELECT FOR UPDATE와 같이 같이 관여할 경우, 락은 언두로그가 아닌 테이블값을 읽기 때문에
Phantom Read가 발생할 수 있습니다.</li>
                      <li>Read Commited : Commit된 데이터만 읽을 수 있도록 하는 설정입니다.
Commit 된 데이터를 읽을 경우 Non Repeatable Read가 발생할 수 있습니다.</li>
                      <li>Read Uncommited : Commit 되지 않은 데이터도 읽을 수 있도록 하는것. 모든 이상현상 발생.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

  </div></details>

<details><summary>정규화</summary><div>
    <ul>
      <li><strong><em>정규화란 무엇인가요? 왜 필요한가요?</em></strong>
        <ul>
          <li>정규화란 데이터베이스 테이블들의 관계에서 중복을 최소화시키는 방법입니다.</li>
        </ul>
      </li>
      <li><strong><em>역정규화?</em></strong>
        <ul>
          <li>테이블에 대한 조인이 성능적으로 문제가 되는 경우(경로가 멀어서)</li>
          <li>조회에 대한 처리성능이 중요하다고 판단된다면</li>
        </ul>
      </li>
    </ul>

  </div></details>

<details><summary>인덱스</summary><div>
    <ul>
      <li><strong><em>인덱스가 무엇인가요? 왜 필요한가요?</em></strong>
        <ul>
          <li>데이터베이스는 랜덤 IO 엑세스와의 싸움입니다.
  추가적인 쓰기작업과 저장공간을 사용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조를 의미합니다.</li>
          <li><strong><em>어떤 자료구조인가요?</em></strong>
            <ul>
              <li>일반적으로는 B+ 트리를 이용합니다.
                <ul>
                  <li><strong><em>왜 B+ 트리를 이용할까요?</em></strong>
                    <ul>
                      <li>B+ 트리는 Leaf Node간 연결이 되어있기때문에
                        <ul>
                          <li>FullScan과 Range Scan에 유리합니다.</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong><em>인덱스의 성능 또는 고려해야할 사항?</em></strong>
        <ul>
          <li>WHERE 절에 자주 사용되는 열</li>
          <li>SELECT 절에 자주 등장하는 칼럼</li>
          <li>JOIN에 자주 사용되는 열</li>
          <li>데이터 중복도가 높은 열은 효과가 없음
            <ul>
              <li>남성/여성</li>
            </ul>
          </li>
          <li>WHERE 절을 변형하면 인덱스를 안타는 이유
            <ul>
              <li>결국 시작점을 알 수 없기 때문임 LIKE 또는 SUBSTR</li>
            </ul>
          </li>
          <li>복합 인덱스를 구성할 때 칼럼의 순서를 고려하는 기준
            <ul>
              <li>분포도는 의미가 없다
                <ul>
                  <li>연산자가 “=” 가 아닐 수 있기 때문</li>
                </ul>
              </li>
              <li>연산자를 최우선적으로 고려하라
                <ul>
                  <li>분포도가 좋더라도 연산자가 선분조건이면 앞에 두는게 안좋을 수 있다는것</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

  </div></details>
 
      </section>

      <footer class="page__meta">
         


  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 카테고리: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#interview" class="page__taxonomy-item p-category" rel="tag">Interview</a>
    
    </span>
  </p>

 

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 업데이트:</strong> <time class="dt-published" datetime="2024-01-24T12:00:00+09:00">January 24, 2024</time></p>

      </footer>
      
  <nav class="pagination">
    
      <a href="#" class="pagination--pager disabled">이전</a>
    
    
      <a href="/interview/ms_network2/" class="pagination--pager" title="CS 면접대비 - 네트워크
">다음</a>
    
  </nav>

    </div>

    
  </article>

   
  <div class="page__related">
    <h2 class="page__related-title">
      참고
    </h2>
    <div class="grid__wrapper">
       



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/concurrency/" rel="permalink">티케팅 시스템 구현에서의 동시성 문제 : 원인
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> April 02 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">개요
</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/architecture/" rel="permalink">스프링 코드 아키텍처
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> March 25 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">작성자 : Claycat

개요

여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?

이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다.
프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요.
결정 과정에 대해서 소개해...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/isp1/" rel="permalink">인터페이스 분리 원칙에 대해
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">다 알고 있는 사실

  어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다
자신이 사용하는 메서드에만 의존해야 한다


매번 나오는 설명입니다.
보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.

interface Person {
	public void ...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/jpa/persistance2/" rel="permalink">영속성 까보기 (feat. 10분 테코톡)
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">JPA와 영속성

JPA 영속성 관련 실험 중 이상한 케이스를 발견했습니다.
우아한형제들 테코톡의 문제상황 1에서도 비슷한 예제가 있습니다.
영상에서는 정확히 이유를 설명하지는 않고 영속성 설명으로 넘어가버려서
정확한 이유를 정리해보려고 합니다.

@Getter
@Entity
@A...</p>
  </article>
</div>
 
    </div>
  </div>
   
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력하세요..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>팔로우:</strong></li>
    

    
      
        
          <li><a href="https://github.com/claycat" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Claycat. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', 'claycat');
    script.setAttribute('data-repo-id', 'R_kgDOLLYTXw');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOLLYTX84Ccyz5');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>
  





  </body>
</html>
