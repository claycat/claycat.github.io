<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>CS 면접대비 - 운영체제 : Claycat</title>
<meta name="description" content="프로세스와 스레드의 차이는?             개념의 추상화에 대응하는 데이터와 코드를 보유할 수 있는 “객체” 와 그 객체간의 상호작용을 통해 프로그램을 작성하는 방법론           프로그램이란?             프로그램이란 디스크에 저장되어있는 실행가능한 파일로, 코드 또는 명령어들의 집합이 담겨져있습니다. 프로그램을 실행하면, 디스크에 있는 명령어들은 메모리에 로드되고 이것을 프로세스 라고 부릅니다.           프로세스는 무엇을 갖고있나요?             프로세스는 프로그램을 실행시키기 위해서 코드/데이터/힙/스택의 메모리 구조로 구성되어 있습니다. 프로세스는 서로 격리되어있다는것이 핵심입니다. 개별적인 메모리 공간을 할당받으며, 하나가 불량으로 인해 실패하더라도 다른 프로세스에 영향을 주지 않습니다. 예를 들면, 크롬과 워드를 동시에 실행하다 워드가 오작동으로 종료되더라도 크롬에는 영향을 주지 않습니다.           스레드는 무엇인가요?             스레드란 프로세스 내부의 실행 단위입니다. 여러개의 스레드가 동시에 하나의 프로세스를 실행시키기 때문에 인터넷 브라우저에서 동영상을 보면서 동시에 파일을 다운로드하는것이 가능합니다. 개별적인 스택 영역을 가짐으로서 독립적인 실행 환경을 갖지만, 스레드끼리 코드, 데이터, 힙 세가지 영역은 공유합니다.           멀티스레딩과 멀티프로세싱의 차이점은 그러면 무엇인가요? 어떤게 더 빠를까요?             결국 멀티스레딩이라는건 하나의 프로세스 안에서 수행하는 병렬 작업이고, 멀티프로세싱은 여러개의 프로세스들을 별도의 프로세스에서 병렬로 수행하는것이다 둘간의 속도를 직접적으로 비교하는것은 의미가 없다. 결국 요구사항의 환경 차이로부터 속도의 차이는 발생한다. 둘의 차이를 생각해보자. 스레드들은 힙 메모리 영역을 공유하는것이 주요한 차이이다.           인터럽트는 무엇인가요? 왜 일어나나요?             CPU가 연산을 하는 중 IO 또는 예외상황 발생으로 인해 우선적인 처리가 필요하다는것을 알리는걸 의미합니다. 인터럽트가 필요한 이유는 IO 과정이 연산보다 매우 느리기 때문입니다. 만약 인터럽트가 없다면, CPU는 계속해서 해당 디바이스를 지켜봐야 할 것입니다. Blocking / Non-Blocking과 연관지어도 좋습니다. 인터럽트를 일종의 콜백으로 본다면, NonBlocking Async 의 형태가 되는것이고 없다면 Blocking Sync의 형태가 될 것입니다.           동시성(Concurrency) 와 병렬성(Parallelism)에 대해서 설명해주세요?             병렬성은 여러개의 물리적인 하드웨어에서 여러개의 작업을 동시에 처리하는것이고, 동시성은 하나의 하드웨어에서 여러개의 프로그램들을 동시에 수행하는것 처럼 보인다           그렇다면 싱글코어 컴퓨터에서 어떻게 멀티프로세싱을 수행하나요?             하나의 프로세서가 존재하더라도 짧은 time slice 안에 여러개의 프로세스를 번갈아가면서 수행하면 우리에게는 동시에 여러개의 프로세스가 수행되는것처럼 보인다.           하나의 프로세스에서 다른 프로세스로 어떻게 전환할 수 있나요?             짧은 시간 안에 프로세스를 전환하기 위해서는 상태를 보존하는 자료구조가 필요한데, 이를 PCB(Process Controll Block) 이라고 부르며, 전환하는 행위를 Context Switching 이라고 부른다.           PCB 내부에는 프로세스의 상태를 저장하는 다양한 정보가 들어있습니다 (program counter, register, pid, …)      해당 PCB를 이용해 다른 프로세스로 전환하고 다시 돌아왔을 때 프로세스의 상태를 복구시켜준다      Context Switch 가 그러면 어떨 때 일어나나요?             배정된 time slice가 만료되거나, 프로세스의 상태를 변경시키는 IO작업의 대기, 또는 우선순위가 높은 작업의 출현 등으로 인해 일어날 수 있습니다          Context Switch가 일어나면 현재 상태는 어떻게 저장되나요?             https://stackoverflow.com/a/68055967           프로세스의 진행 중 스위칭이 일어날 경우 현재의 실행 컨텍스트는 (프로세스의 상태나 프로그램 카운터) 커널 스택에 저장됩니다 PID등 프로세스에 관련된 정보는 PCB에 저장됩니다             PCB와 커널 스택 둘다 Context Switch 시에 필요한 정보를 담고 있다. 어떤 값을 들고있는지는 OS마다 다르고, 정확하게 정할 수는 없다.       PCB는 일반적으로 Kernel Stack 내부에 존재한다           그렇다면 스레드에도 PCB가 존재하나요?                      https://stackoverflow.com/a/68055967                       PCB의 명칭상 스레드에 PCB가 존재한다고는 말할 수 없지만, TCB라는 유사한 저장소가 존재한다 PCB와 유사하게 stack pointer, register 등 TCB에도 스레드의 상태를 기록하는 정보들이 존재하며, 프로세스보다는 작은 규모이다.                  Kernel Level Thread 와 User Level Thread 의 차이는 무엇인가요?      https://stackoverflow.com/a/59634931      인터넷에 정확한 설명이 매우 부족한 부분인데, 간혹 나오는것같아 첨부한다 Kernel을 동작시키는 스레드 != Kernel 스레드 원점으로 돌아가보자. 하나의 코어를 갖고 있는 시스템에서 커널은 어떤 작업을 하는가? 여러개의 스레드가 연속적으로 context switching을 수행해주는걸 관리해준다. Kernel 스레드는 어디까지나 이 개념을 조금 확장한것일뿐이다.      하나의 프로세스는 하나의 커널 스레드를 보유한 상태에서 시작한다. 즉, 싱글 스레드 앱이라면 모든 작업이 커널 스레드에서 수행된다. 당연하게도 PCB는 여기서 관리한다      하지만 프로세스를 여러개의 유저 스레드라는 일종의 유사 스레드로 실행될 수 있다. 일반적으로 라이브러리 등을 통해 생성되는 유저 스레드는 OS에서 관리하는 실제 스레드와는 다른 유사 스레드이다. 해당 유저 스레드의 스케쥴링은 라이브러리의 정책에 따라 관리되며 커널은 해당 프로세스의 분기에 대해서 전혀 알지 못한다 (하나의 프로세스로 볼 뿐)        운영체제 / IPC  IPC에 대해서 설명해주세요      프로세스는 서로 격리되어있기 때문에 스레드와 같이 힙, 코드, 데이터 영역등을 공유하는 방식으로 소통할 수 없습니다. 따라서 별도의 통신 메커니즘을 이용하는데, 이것을 IPC라고 부릅니다. 아래와 같이 로컬 통신 방식             Pipe를 이용한 Message passing                    단방향 통신만 가능한 익명 파이프                            양방향 통신을 위해서는 두개의 파이프 (read - write)전용 파이프를 만들어야 한다                                   양방향 통신이 가능한 명명 파이프                                공유 메모리 사용                     파이프만으로 해결할 수 없는 경우 사용           동시성 문제를 주의해야 함                           또는 네트워크 통신 방식인             소켓 통신       RPC                    Remote Procedure Call                            클라이언트에서 서버에 위치한 프로시저를 호출할 수 있게 하는 프로토콜                                                   등이 있습니다.      프로세스 스케쥴링 알고리즘에는 뭐가 있나요?                      가장 단순한 FIFO부터 설명드리겠습니다. 먼저 들어온 작업이 먼저 끝나는 형식의 FIFO는 단순하지만, Convoy Effect라는 오래 걸리는 프로세스가 앞에서 점유하고 있을 경우, 뒤 작업들의 처리시간이 늘어나는 문제가 있습니다. 이것을 극복하기 위해서 Shortest Job First 라는 가장 짧은 시간이 걸리는 프로세스를 먼저 처리하는 방법이 존재하지만 역시 starvation 문제가 있습니다.                       이 문제들을 해결하기 위해서 프로세스를 중간에 가로채는 선점 스케쥴링 방식이 등장합니다. 예시로 Round robin이 있지만, 이 경우 또한 Context Switching 비용을 신경써야 합니다.                  데드락에 대해서 설명해주세요             두개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 못하는 상태를 의미합니다. 예를 들어 A와 B가 두개의 종이에 쓰여 있는 숫자 두개를 더하고 싶을 때, A가 종이1을 얻고 B가 종이2를 얻었을 때 서로 다른 종이를 얻기 위해 기다리는 상황입니다.           경쟁 상태에 대해서 설명해주세요             공유 자원에 대해서 두개 이상의 프로세스나 스레드가 접근할 때 생길 수 있는 문제를 의미합니다. 덧셈 코드가 load/add/store로 나뉘어 있는것을 생각하면 설명하기 좋습니다. 경쟁 상태를 해결할 수 있는 방법으로 Mutual Exclusion이 있는데, 이것은 데드락의 발생조건 중 하나입니다.           Mutex와 Semaphore             경쟁상태를 해결하기 위해서 일종의 락을 데이터에 걸어주는 것입니다. 화장실과 화장실 키를 생각해볼 수 있습니다. 하나의 프로세스가 Mutex를 보유했을 때, 다른 프로세스는 접근할 수 없습니다. 세마포어는 이것의 확장입니다. P(S)로 Semaphore를 감소시키면 busy waiting 하거나 대기 큐로 옮기고 V(S)로 Semaphore를 증가시키면 대기 큐에서 P를 꺼내 실행시킵니다             파일 시스템  파일 시스템이란 무엇인가요?             디스크에 접근하는것을 OS 레벨에서 추상화한 것입니다.           프로세스에서 파일을 어떻게 읽나요?             디스크에 접근하는것을 OS 레벨에서 추상화한 것입니다.                  파일 열람을 위한 시스템 콜이 호출됩니다.                  파일의 경로와 읽기 모드를 명시하면 운영체제에서 파일 open 시스템 콜을 호출합니다.       파일을 성공적으로 읽었을 경우, file descriptor 가 반환됩니다.                    file descriptor란 현재 열려있는 파일의 식별자로 사용되는 정수값입니다.                       파일 내용을 읽기 위해서 read 시스템 콜이 호출됩니다. 읽은 내용은 버퍼로 옮겨집니다.       파일 시스템을 통해서 저장장치에 있는 정보를 읽고, 프로세스의 메모리로 복사됩니다.       읽은 파일의 총 바이트 수를 반환합니다.       close 시스템 콜을 날려 파일을 닫습니다.             페이지  페이징이 왜 필요한가요?">



<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="Claycat">
<meta property="og:title" content="CS 면접대비 - 운영체제">
<meta property="og:url" content="http://localhost:4000/interview/ms_os1/">


  <meta property="og:description" content="프로세스와 스레드의 차이는?             개념의 추상화에 대응하는 데이터와 코드를 보유할 수 있는 “객체” 와 그 객체간의 상호작용을 통해 프로그램을 작성하는 방법론           프로그램이란?             프로그램이란 디스크에 저장되어있는 실행가능한 파일로, 코드 또는 명령어들의 집합이 담겨져있습니다. 프로그램을 실행하면, 디스크에 있는 명령어들은 메모리에 로드되고 이것을 프로세스 라고 부릅니다.           프로세스는 무엇을 갖고있나요?             프로세스는 프로그램을 실행시키기 위해서 코드/데이터/힙/스택의 메모리 구조로 구성되어 있습니다. 프로세스는 서로 격리되어있다는것이 핵심입니다. 개별적인 메모리 공간을 할당받으며, 하나가 불량으로 인해 실패하더라도 다른 프로세스에 영향을 주지 않습니다. 예를 들면, 크롬과 워드를 동시에 실행하다 워드가 오작동으로 종료되더라도 크롬에는 영향을 주지 않습니다.           스레드는 무엇인가요?             스레드란 프로세스 내부의 실행 단위입니다. 여러개의 스레드가 동시에 하나의 프로세스를 실행시키기 때문에 인터넷 브라우저에서 동영상을 보면서 동시에 파일을 다운로드하는것이 가능합니다. 개별적인 스택 영역을 가짐으로서 독립적인 실행 환경을 갖지만, 스레드끼리 코드, 데이터, 힙 세가지 영역은 공유합니다.           멀티스레딩과 멀티프로세싱의 차이점은 그러면 무엇인가요? 어떤게 더 빠를까요?             결국 멀티스레딩이라는건 하나의 프로세스 안에서 수행하는 병렬 작업이고, 멀티프로세싱은 여러개의 프로세스들을 별도의 프로세스에서 병렬로 수행하는것이다 둘간의 속도를 직접적으로 비교하는것은 의미가 없다. 결국 요구사항의 환경 차이로부터 속도의 차이는 발생한다. 둘의 차이를 생각해보자. 스레드들은 힙 메모리 영역을 공유하는것이 주요한 차이이다.           인터럽트는 무엇인가요? 왜 일어나나요?             CPU가 연산을 하는 중 IO 또는 예외상황 발생으로 인해 우선적인 처리가 필요하다는것을 알리는걸 의미합니다. 인터럽트가 필요한 이유는 IO 과정이 연산보다 매우 느리기 때문입니다. 만약 인터럽트가 없다면, CPU는 계속해서 해당 디바이스를 지켜봐야 할 것입니다. Blocking / Non-Blocking과 연관지어도 좋습니다. 인터럽트를 일종의 콜백으로 본다면, NonBlocking Async 의 형태가 되는것이고 없다면 Blocking Sync의 형태가 될 것입니다.           동시성(Concurrency) 와 병렬성(Parallelism)에 대해서 설명해주세요?             병렬성은 여러개의 물리적인 하드웨어에서 여러개의 작업을 동시에 처리하는것이고, 동시성은 하나의 하드웨어에서 여러개의 프로그램들을 동시에 수행하는것 처럼 보인다           그렇다면 싱글코어 컴퓨터에서 어떻게 멀티프로세싱을 수행하나요?             하나의 프로세서가 존재하더라도 짧은 time slice 안에 여러개의 프로세스를 번갈아가면서 수행하면 우리에게는 동시에 여러개의 프로세스가 수행되는것처럼 보인다.           하나의 프로세스에서 다른 프로세스로 어떻게 전환할 수 있나요?             짧은 시간 안에 프로세스를 전환하기 위해서는 상태를 보존하는 자료구조가 필요한데, 이를 PCB(Process Controll Block) 이라고 부르며, 전환하는 행위를 Context Switching 이라고 부른다.           PCB 내부에는 프로세스의 상태를 저장하는 다양한 정보가 들어있습니다 (program counter, register, pid, …)      해당 PCB를 이용해 다른 프로세스로 전환하고 다시 돌아왔을 때 프로세스의 상태를 복구시켜준다      Context Switch 가 그러면 어떨 때 일어나나요?             배정된 time slice가 만료되거나, 프로세스의 상태를 변경시키는 IO작업의 대기, 또는 우선순위가 높은 작업의 출현 등으로 인해 일어날 수 있습니다          Context Switch가 일어나면 현재 상태는 어떻게 저장되나요?             https://stackoverflow.com/a/68055967           프로세스의 진행 중 스위칭이 일어날 경우 현재의 실행 컨텍스트는 (프로세스의 상태나 프로그램 카운터) 커널 스택에 저장됩니다 PID등 프로세스에 관련된 정보는 PCB에 저장됩니다             PCB와 커널 스택 둘다 Context Switch 시에 필요한 정보를 담고 있다. 어떤 값을 들고있는지는 OS마다 다르고, 정확하게 정할 수는 없다.       PCB는 일반적으로 Kernel Stack 내부에 존재한다           그렇다면 스레드에도 PCB가 존재하나요?                      https://stackoverflow.com/a/68055967                       PCB의 명칭상 스레드에 PCB가 존재한다고는 말할 수 없지만, TCB라는 유사한 저장소가 존재한다 PCB와 유사하게 stack pointer, register 등 TCB에도 스레드의 상태를 기록하는 정보들이 존재하며, 프로세스보다는 작은 규모이다.                  Kernel Level Thread 와 User Level Thread 의 차이는 무엇인가요?      https://stackoverflow.com/a/59634931      인터넷에 정확한 설명이 매우 부족한 부분인데, 간혹 나오는것같아 첨부한다 Kernel을 동작시키는 스레드 != Kernel 스레드 원점으로 돌아가보자. 하나의 코어를 갖고 있는 시스템에서 커널은 어떤 작업을 하는가? 여러개의 스레드가 연속적으로 context switching을 수행해주는걸 관리해준다. Kernel 스레드는 어디까지나 이 개념을 조금 확장한것일뿐이다.      하나의 프로세스는 하나의 커널 스레드를 보유한 상태에서 시작한다. 즉, 싱글 스레드 앱이라면 모든 작업이 커널 스레드에서 수행된다. 당연하게도 PCB는 여기서 관리한다      하지만 프로세스를 여러개의 유저 스레드라는 일종의 유사 스레드로 실행될 수 있다. 일반적으로 라이브러리 등을 통해 생성되는 유저 스레드는 OS에서 관리하는 실제 스레드와는 다른 유사 스레드이다. 해당 유저 스레드의 스케쥴링은 라이브러리의 정책에 따라 관리되며 커널은 해당 프로세스의 분기에 대해서 전혀 알지 못한다 (하나의 프로세스로 볼 뿐)        운영체제 / IPC  IPC에 대해서 설명해주세요      프로세스는 서로 격리되어있기 때문에 스레드와 같이 힙, 코드, 데이터 영역등을 공유하는 방식으로 소통할 수 없습니다. 따라서 별도의 통신 메커니즘을 이용하는데, 이것을 IPC라고 부릅니다. 아래와 같이 로컬 통신 방식             Pipe를 이용한 Message passing                    단방향 통신만 가능한 익명 파이프                            양방향 통신을 위해서는 두개의 파이프 (read - write)전용 파이프를 만들어야 한다                                   양방향 통신이 가능한 명명 파이프                                공유 메모리 사용                     파이프만으로 해결할 수 없는 경우 사용           동시성 문제를 주의해야 함                           또는 네트워크 통신 방식인             소켓 통신       RPC                    Remote Procedure Call                            클라이언트에서 서버에 위치한 프로시저를 호출할 수 있게 하는 프로토콜                                                   등이 있습니다.      프로세스 스케쥴링 알고리즘에는 뭐가 있나요?                      가장 단순한 FIFO부터 설명드리겠습니다. 먼저 들어온 작업이 먼저 끝나는 형식의 FIFO는 단순하지만, Convoy Effect라는 오래 걸리는 프로세스가 앞에서 점유하고 있을 경우, 뒤 작업들의 처리시간이 늘어나는 문제가 있습니다. 이것을 극복하기 위해서 Shortest Job First 라는 가장 짧은 시간이 걸리는 프로세스를 먼저 처리하는 방법이 존재하지만 역시 starvation 문제가 있습니다.                       이 문제들을 해결하기 위해서 프로세스를 중간에 가로채는 선점 스케쥴링 방식이 등장합니다. 예시로 Round robin이 있지만, 이 경우 또한 Context Switching 비용을 신경써야 합니다.                  데드락에 대해서 설명해주세요             두개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 못하는 상태를 의미합니다. 예를 들어 A와 B가 두개의 종이에 쓰여 있는 숫자 두개를 더하고 싶을 때, A가 종이1을 얻고 B가 종이2를 얻었을 때 서로 다른 종이를 얻기 위해 기다리는 상황입니다.           경쟁 상태에 대해서 설명해주세요             공유 자원에 대해서 두개 이상의 프로세스나 스레드가 접근할 때 생길 수 있는 문제를 의미합니다. 덧셈 코드가 load/add/store로 나뉘어 있는것을 생각하면 설명하기 좋습니다. 경쟁 상태를 해결할 수 있는 방법으로 Mutual Exclusion이 있는데, 이것은 데드락의 발생조건 중 하나입니다.           Mutex와 Semaphore             경쟁상태를 해결하기 위해서 일종의 락을 데이터에 걸어주는 것입니다. 화장실과 화장실 키를 생각해볼 수 있습니다. 하나의 프로세스가 Mutex를 보유했을 때, 다른 프로세스는 접근할 수 없습니다. 세마포어는 이것의 확장입니다. P(S)로 Semaphore를 감소시키면 busy waiting 하거나 대기 큐로 옮기고 V(S)로 Semaphore를 증가시키면 대기 큐에서 P를 꺼내 실행시킵니다             파일 시스템  파일 시스템이란 무엇인가요?             디스크에 접근하는것을 OS 레벨에서 추상화한 것입니다.           프로세스에서 파일을 어떻게 읽나요?             디스크에 접근하는것을 OS 레벨에서 추상화한 것입니다.                  파일 열람을 위한 시스템 콜이 호출됩니다.                  파일의 경로와 읽기 모드를 명시하면 운영체제에서 파일 open 시스템 콜을 호출합니다.       파일을 성공적으로 읽었을 경우, file descriptor 가 반환됩니다.                    file descriptor란 현재 열려있는 파일의 식별자로 사용되는 정수값입니다.                       파일 내용을 읽기 위해서 read 시스템 콜이 호출됩니다. 읽은 내용은 버퍼로 옮겨집니다.       파일 시스템을 통해서 저장장치에 있는 정보를 읽고, 프로세스의 메모리로 복사됩니다.       읽은 파일의 총 바이트 수를 반환합니다.       close 시스템 콜을 날려 파일을 닫습니다.             페이지  페이징이 왜 필요한가요?">







  <meta property="article:published_time" content="2024-01-24T12:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/interview/ms_os1/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Claycat",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Claycat Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->



<link
  rel="apple-touch-icon"
  sizes="180x180"
  href="/assets/images/favicons/apple-touch-icon.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="32x32"
  href="/assets/images/favicons/favicon-32x32.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="16x16"
  href="/assets/images/favicons/favicon-16x16.png"
/>

<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico" />
<meta name="apple-mobile-web-app-title" content="Claycat" />
<meta name="application-name" content="Claycat" />
<meta name="msapplication-TileColor" content="#da532c" />
<meta
  name="msapplication-config"
  content="/assets/images/favicons/browserconfig.xml"
/>
<meta name="theme-color" content="#ffffff" />

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Claycat
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
         

<div id="main" role="main">
  


  <article
    class="page h-entry"
    itemscope
    itemtype="https://schema.org/CreativeWork"
  >
    <meta
      itemprop="headline"
      content="CS 면접대비 - 운영체제"
    /> <meta
      itemprop="description"
      content="프로세스와 스레드의 차이는?          개념의 추상화에 대응하는 데이터와 코드를 보유할 수 있는 “객체” 와 그 객체간의 상호작용을 통해 프로그램을 작성하는 방법론      프로그램이란?          프로그램이란 디스크에 저장되어있는 실행가능한 파일로, 코드 또는 명령어들의 집합이 담겨져있습니다.프로그램을 실행하면, 디스크에 있는 명령어들은 메모리에 로드되고 이것을 프로세스 라고 부릅니다.      프로세스는 무엇을 갖고있나요?          프로세스는 프로그램을 실행시키기 위해서 코드/데이터/힙/스택의 메모리 구조로 구성되어 있습니다.프로세스는 서로 격리되어있다는것이 핵심입니다.개별적인 메모리 공간을 할당받으며, 하나가 불량으로 인해 실패하더라도 다른 프로세스에 영향을 주지 않습니다.예를 들면, 크롬과 워드를 동시에 실행하다 워드가 오작동으로 종료되더라도 크롬에는 영향을 주지 않습니다.      스레드는 무엇인가요?          스레드란 프로세스 내부의 실행 단위입니다.여러개의 스레드가 동시에 하나의 프로세스를 실행시키기 때문에 인터넷 브라우저에서 동영상을 보면서 동시에 파일을 다운로드하는것이 가능합니다.개별적인 스택 영역을 가짐으로서 독립적인 실행 환경을 갖지만,스레드끼리 코드, 데이터, 힙 세가지 영역은 공유합니다.      멀티스레딩과 멀티프로세싱의 차이점은 그러면 무엇인가요? 어떤게 더 빠를까요?          결국 멀티스레딩이라는건 하나의 프로세스 안에서 수행하는 병렬 작업이고,멀티프로세싱은 여러개의 프로세스들을 별도의 프로세스에서 병렬로 수행하는것이다둘간의 속도를 직접적으로 비교하는것은 의미가 없다. 결국 요구사항의 환경 차이로부터 속도의 차이는 발생한다.둘의 차이를 생각해보자. 스레드들은 힙 메모리 영역을 공유하는것이 주요한 차이이다.      인터럽트는 무엇인가요? 왜 일어나나요?          CPU가 연산을 하는 중 IO 또는 예외상황 발생으로 인해 우선적인 처리가 필요하다는것을 알리는걸 의미합니다.인터럽트가 필요한 이유는 IO 과정이 연산보다 매우 느리기 때문입니다.만약 인터럽트가 없다면, CPU는 계속해서 해당 디바이스를 지켜봐야 할 것입니다.Blocking / Non-Blocking과 연관지어도 좋습니다.인터럽트를 일종의 콜백으로 본다면, NonBlocking Async 의 형태가 되는것이고없다면 Blocking Sync의 형태가 될 것입니다.      동시성(Concurrency) 와 병렬성(Parallelism)에 대해서 설명해주세요?          병렬성은 여러개의 물리적인 하드웨어에서 여러개의 작업을 동시에 처리하는것이고,동시성은 하나의 하드웨어에서 여러개의 프로그램들을 동시에 수행하는것 처럼 보인다      그렇다면 싱글코어 컴퓨터에서 어떻게 멀티프로세싱을 수행하나요?          하나의 프로세서가 존재하더라도 짧은 time slice 안에 여러개의 프로세스를 번갈아가면서 수행하면 우리에게는 동시에 여러개의 프로세스가 수행되는것처럼 보인다.      하나의 프로세스에서 다른 프로세스로 어떻게 전환할 수 있나요?          짧은 시간 안에 프로세스를 전환하기 위해서는 상태를 보존하는 자료구조가 필요한데, 이를 PCB(Process Controll Block) 이라고 부르며, 전환하는 행위를 Context Switching 이라고 부른다.        PCB 내부에는 프로세스의 상태를 저장하는 다양한 정보가 들어있습니다 (program counter, register, pid, …)    해당 PCB를 이용해 다른 프로세스로 전환하고 다시 돌아왔을 때 프로세스의 상태를 복구시켜준다  Context Switch 가 그러면 어떨 때 일어나나요?          배정된 time slice가 만료되거나, 프로세스의 상태를 변경시키는 IO작업의 대기, 또는 우선순위가 높은 작업의 출현 등으로 인해 일어날 수 있습니다      Context Switch가 일어나면 현재 상태는 어떻게 저장되나요?          https://stackoverflow.com/a/68055967        프로세스의 진행 중 스위칭이 일어날 경우 현재의 실행 컨텍스트는 (프로세스의 상태나 프로그램 카운터) 커널 스택에 저장됩니다 PID등 프로세스에 관련된 정보는 PCB에 저장됩니다          PCB와 커널 스택 둘다 Context Switch 시에 필요한 정보를 담고 있다.어떤 값을 들고있는지는 OS마다 다르고, 정확하게 정할 수는 없다.      PCB는 일반적으로 Kernel Stack 내부에 존재한다      그렇다면 스레드에도 PCB가 존재하나요?                  https://stackoverflow.com/a/68055967                    PCB의 명칭상 스레드에 PCB가 존재한다고는 말할 수 없지만, TCB라는 유사한 저장소가 존재한다PCB와 유사하게 stack pointer, register 등 TCB에도 스레드의 상태를 기록하는 정보들이 존재하며, 프로세스보다는 작은 규모이다.            Kernel Level Thread 와 User Level Thread 의 차이는 무엇인가요?    https://stackoverflow.com/a/59634931    인터넷에 정확한 설명이 매우 부족한 부분인데, 간혹 나오는것같아 첨부한다Kernel을 동작시키는 스레드 != Kernel 스레드원점으로 돌아가보자. 하나의 코어를 갖고 있는 시스템에서 커널은 어떤 작업을 하는가?여러개의 스레드가 연속적으로 context switching을 수행해주는걸 관리해준다.Kernel 스레드는 어디까지나 이 개념을 조금 확장한것일뿐이다.    하나의 프로세스는 하나의 커널 스레드를 보유한 상태에서 시작한다. 즉, 싱글 스레드 앱이라면 모든 작업이 커널 스레드에서 수행된다. 당연하게도 PCB는 여기서 관리한다    하지만 프로세스를 여러개의 유저 스레드라는 일종의 유사 스레드로 실행될 수 있다.일반적으로 라이브러리 등을 통해 생성되는 유저 스레드는 OS에서 관리하는 실제 스레드와는 다른 유사 스레드이다. 해당 유저 스레드의 스케쥴링은 라이브러리의 정책에 따라 관리되며 커널은 해당 프로세스의 분기에 대해서 전혀 알지 못한다 (하나의 프로세스로 볼 뿐)  운영체제 / IPCIPC에 대해서 설명해주세요    프로세스는 서로 격리되어있기 때문에 스레드와 같이 힙, 코드, 데이터 영역등을 공유하는 방식으로 소통할 수 없습니다.따라서 별도의 통신 메커니즘을 이용하는데, 이것을 IPC라고 부릅니다.아래와 같이 로컬 통신 방식          Pipe를 이용한 Message passing                  단방향 통신만 가능한 익명 파이프                          양방향 통신을 위해서는 두개의 파이프 (read - write)전용 파이프를 만들어야 한다                                양방향 통신이 가능한 명명 파이프                            공유 메모리 사용                  파이프만으로 해결할 수 없는 경우 사용          동시성 문제를 주의해야 함                      또는 네트워크 통신 방식인          소켓 통신      RPC                  Remote Procedure Call                          클라이언트에서 서버에 위치한 프로시저를 호출할 수 있게 하는 프로토콜                                            등이 있습니다.  프로세스 스케쥴링 알고리즘에는 뭐가 있나요?                  가장 단순한 FIFO부터 설명드리겠습니다.먼저 들어온 작업이 먼저 끝나는 형식의 FIFO는 단순하지만, Convoy Effect라는오래 걸리는 프로세스가 앞에서 점유하고 있을 경우, 뒤 작업들의 처리시간이 늘어나는 문제가 있습니다.이것을 극복하기 위해서 Shortest Job First 라는 가장 짧은 시간이 걸리는 프로세스를 먼저 처리하는방법이 존재하지만 역시 starvation 문제가 있습니다.                    이 문제들을 해결하기 위해서 프로세스를 중간에 가로채는 선점 스케쥴링 방식이 등장합니다.예시로 Round robin이 있지만, 이 경우 또한 Context Switching 비용을 신경써야 합니다.            데드락에 대해서 설명해주세요          두개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 못하는 상태를 의미합니다.예를 들어 A와 B가 두개의 종이에 쓰여 있는 숫자 두개를 더하고 싶을 때,A가 종이1을 얻고 B가 종이2를 얻었을 때 서로 다른 종이를 얻기 위해 기다리는 상황입니다.      경쟁 상태에 대해서 설명해주세요          공유 자원에 대해서 두개 이상의 프로세스나 스레드가 접근할 때 생길 수 있는 문제를 의미합니다.덧셈 코드가 load/add/store로 나뉘어 있는것을 생각하면 설명하기 좋습니다.경쟁 상태를 해결할 수 있는 방법으로 Mutual Exclusion이 있는데, 이것은 데드락의 발생조건 중 하나입니다.      Mutex와 Semaphore          경쟁상태를 해결하기 위해서 일종의 락을 데이터에 걸어주는 것입니다.화장실과 화장실 키를 생각해볼 수 있습니다.하나의 프로세스가 Mutex를 보유했을 때, 다른 프로세스는 접근할 수 없습니다.세마포어는 이것의 확장입니다.P(S)로 Semaphore를 감소시키면 busy waiting 하거나 대기 큐로 옮기고V(S)로 Semaphore를 증가시키면 대기 큐에서 P를 꺼내 실행시킵니다      파일 시스템파일 시스템이란 무엇인가요?          디스크에 접근하는것을 OS 레벨에서 추상화한 것입니다.      프로세스에서 파일을 어떻게 읽나요?          디스크에 접근하는것을 OS 레벨에서 추상화한 것입니다.              파일 열람을 위한 시스템 콜이 호출됩니다.              파일의 경로와 읽기 모드를 명시하면 운영체제에서 파일 open 시스템 콜을 호출합니다.      파일을 성공적으로 읽었을 경우, file descriptor 가 반환됩니다.                  file descriptor란 현재 열려있는 파일의 식별자로 사용되는 정수값입니다.                    파일 내용을 읽기 위해서 read 시스템 콜이 호출됩니다.읽은 내용은 버퍼로 옮겨집니다.      파일 시스템을 통해서 저장장치에 있는 정보를 읽고, 프로세스의 메모리로 복사됩니다.      읽은 파일의 총 바이트 수를 반환합니다.      close 시스템 콜을 날려 파일을 닫습니다.      페이지페이징이 왜 필요한가요?  "
    /> <meta
      itemprop="datePublished"
      content="2024-01-24T12:00:00+09:00"
    /> 

    <div class="page__inner-wrap">
      
      <header>
        
        <h1 id="page-title" class="page__title" itemprop="headline">
          <p>CS 면접대비 - 운영체제</p>

        </h1>
         
      </header>
      

      <section class="page__content e-content" itemprop="text">
         <details><summary>프로세스와 스레드의 차이는?</summary><div>

    <ul>
      <li>개념의 추상화에 대응하는 데이터와 코드를 보유할 수 있는 “객체” 와 그 객체간의 상호작용을 통해 프로그램을 작성하는 방법론</li>
    </ul>

  </div></details>

<details><summary>프로그램이란?</summary><div>

    <ul>
      <li><strong>프로그램이란 디스크에 저장되어있는 실행가능한 파일로</strong>, 코드 또는 명령어들의 집합이 담겨져있습니다.<br />
프로그램을 실행하면, 디스크에 있는 명령어들은 메모리에 로드되고 이것을 <strong>프로세스</strong> 라고 부릅니다.</li>
    </ul>

  </div></details>

<details><summary>프로세스는 무엇을 갖고있나요?</summary><div>

    <ul>
      <li>프로세스는 프로그램을 실행시키기 위해서 코드/데이터/힙/스택의 메모리 구조로 구성되어 있습니다.<br />
프로세스는 서로 <strong>격리</strong>되어있다는것이 핵심입니다.<br />
개별적인 메모리 공간을 할당받으며, 하나가 불량으로 인해 실패하더라도 다른 프로세스에 영향을 주지 않습니다.<br />
예를 들면, 크롬과 워드를 동시에 실행하다 워드가 오작동으로 종료되더라도 크롬에는 영향을 주지 않습니다.</li>
    </ul>

  </div></details>

<details><summary>스레드는 무엇인가요?</summary><div>

    <ul>
      <li>스레드란 프로세스 내부의 실행 단위입니다.<br />
여러개의 스레드가 동시에 하나의 프로세스를 실행시키기 때문에 인터넷 브라우저에서 동영상을 보면서 동시에 파일을 다운로드하는것이 가능합니다.<br />
개별적인 스택 영역을 가짐으로서 독립적인 실행 환경을 갖지만,<br />
스레드끼리 코드, 데이터, 힙 세가지 영역은 공유합니다.</li>
    </ul>

  </div></details>

<details><summary>멀티스레딩과 멀티프로세싱의 차이점은 그러면 무엇인가요? 어떤게 더 빠를까요?</summary><div>

    <ul>
      <li>결국 멀티스레딩이라는건 하나의 프로세스 안에서 수행하는 병렬 작업이고,<br />
멀티프로세싱은 여러개의 프로세스들을 별도의 프로세스에서 병렬로 수행하는것이다<br />
둘간의 속도를 직접적으로 비교하는것은 의미가 없다. 결국 요구사항의 환경 차이로부터 속도의 차이는 발생한다.<br />
둘의 차이를 생각해보자. 스레드들은 힙 메모리 영역을 공유하는것이 주요한 차이이다.</li>
    </ul>

  </div></details>

<details><summary>인터럽트는 무엇인가요? 왜 일어나나요?</summary><div>

    <ul>
      <li>CPU가 연산을 하는 중 IO 또는 예외상황 발생으로 인해 우선적인 처리가 필요하다는것을 알리는걸 의미합니다.<br />
인터럽트가 필요한 이유는 IO 과정이 연산보다 매우 느리기 때문입니다.<br />
만약 인터럽트가 없다면, CPU는 계속해서 해당 디바이스를 지켜봐야 할 것입니다.<br />
Blocking / Non-Blocking과 연관지어도 좋습니다.<br />
인터럽트를 일종의 콜백으로 본다면, NonBlocking Async 의 형태가 되는것이고<br />
없다면 Blocking Sync의 형태가 될 것입니다.</li>
    </ul>

  </div></details>

<details><summary>동시성(Concurrency) 와 병렬성(Parallelism)에 대해서 설명해주세요?</summary><div>

    <ul>
      <li>병렬성은 여러개의 물리적인 하드웨어에서 여러개의 작업을 동시에 처리하는것이고,<br />
동시성은 하나의 하드웨어에서 여러개의 프로그램들을 동시에 수행하는것 처럼 보인다</li>
    </ul>

  </div></details>

<details><summary>그렇다면 싱글코어 컴퓨터에서 어떻게 멀티프로세싱을 수행하나요?</summary><div>

    <ul>
      <li>하나의 프로세서가 존재하더라도 짧은 time slice 안에 여러개의 프로세스를 번갈아가면서 수행하면 우리에게는 동시에 여러개의 프로세스가 수행되는것처럼 보인다.</li>
    </ul>

  </div></details>

<details><summary>하나의 프로세스에서 다른 프로세스로 어떻게 전환할 수 있나요?</summary><div>

    <ul>
      <li>짧은 시간 안에 프로세스를 전환하기 위해서는 상태를 보존하는 자료구조가 필요한데, 이를 PCB(Process Controll Block) 이라고 부르며, 전환하는 행위를 Context Switching 이라고 부른다.</li>
    </ul>

    <p>PCB 내부에는 프로세스의 상태를 저장하는 다양한 정보가 들어있습니다 (program counter, register, pid, …)</p>

    <p>해당 PCB를 이용해 다른 프로세스로 전환하고 다시 돌아왔을 때 프로세스의 상태를 복구시켜준다</p>

  </div></details>

<details><summary>Context Switch 가 그러면 어떨 때 일어나나요?</summary><div>

    <ul>
      <li>배정된 time slice가 만료되거나, 프로세스의 상태를 변경시키는 IO작업의 대기, 또는 우선순위가 높은 작업의 출현 등으로 인해 일어날 수 있습니다</li>
    </ul>
  </div></details>

<details><summary>Context Switch가 일어나면 현재 상태는 어떻게 저장되나요?</summary><div>

    <ul>
      <li><a href="https://stackoverflow.com/a/68055967">https://stackoverflow.com/a/68055967</a></li>
    </ul>

    <p>프로세스의 진행 중 스위칭이 일어날 경우 현재의 실행 컨텍스트는 (프로세스의 상태나 프로그램 카운터) 커널 스택에 저장됩니다 PID등 프로세스에 관련된 정보는 PCB에 저장됩니다</p>

    <ul>
      <li>PCB와 커널 스택 둘다 Context Switch 시에 필요한 정보를 담고 있다.
어떤 값을 들고있는지는 OS마다 다르고, 정확하게 정할 수는 없다.</li>
      <li>PCB는 일반적으로 Kernel Stack 내부에 존재한다</li>
    </ul>

  </div></details>

<details><summary>그렇다면 스레드에도 PCB가 존재하나요?</summary><div>

    <ul>
      <li>
        <p><a href="https://stackoverflow.com/a/68055967">https://stackoverflow.com/a/68055967</a></p>
      </li>
      <li>
        <p>PCB의 명칭상 스레드에 PCB가 존재한다고는 말할 수 없지만, TCB라는 유사한 저장소가 존재한다<br />
PCB와 유사하게 stack pointer, register 등 TCB에도 스레드의 상태를 기록하는 정보들이 존재하며, 프로세스보다는 작은 규모이다.</p>
      </li>
    </ul>

  </div></details>

<details><summary>Kernel Level Thread 와 User Level Thread 의 차이는 무엇인가요?</summary><div>

    <p><a href="https://stackoverflow.com/a/59634931">https://stackoverflow.com/a/59634931</a></p>

    <p>인터넷에 정확한 설명이 매우 부족한 부분인데, 간혹 나오는것같아 첨부한다<br />
Kernel을 동작시키는 스레드 != Kernel 스레드<br />
원점으로 돌아가보자. 하나의 코어를 갖고 있는 시스템에서 커널은 어떤 작업을 하는가?<br />
여러개의 스레드가 연속적으로 context switching을 수행해주는걸 관리해준다.<br />
Kernel 스레드는 어디까지나 이 개념을 조금 확장한것일뿐이다.</p>

    <p>하나의 프로세스는 하나의 커널 스레드를 보유한 상태에서 시작한다. 즉, 싱글 스레드 앱이라면 모든 작업이 커널 스레드에서 수행된다. 당연하게도 PCB는 여기서 관리한다</p>

    <p>하지만 프로세스를 여러개의 유저 스레드라는 일종의 유사 스레드로 실행될 수 있다.<br />
일반적으로 라이브러리 등을 통해 생성되는 유저 스레드는 OS에서 관리하는 실제 스레드와는 다른 유사 스레드이다. 해당 유저 스레드의 스케쥴링은 라이브러리의 정책에 따라 관리되며 커널은 해당 프로세스의 분기에 대해서 전혀 알지 못한다 (하나의 프로세스로 볼 뿐)</p>

  </div></details>

<hr />

<h1 id="운영체제--ipc">운영체제 / IPC</h1>

<details><summary>IPC에 대해서 설명해주세요</summary><div>

    <p>프로세스는 서로 격리되어있기 때문에 스레드와 같이 힙, 코드, 데이터 영역등을 공유하는 방식으로 소통할 수 없습니다.<br />
따라서 별도의 통신 메커니즘을 이용하는데, 이것을 IPC라고 부릅니다.<br />
아래와 같이 로컬 통신 방식</p>

    <ul>
      <li>Pipe를 이용한 Message passing
        <ul>
          <li>단방향 통신만 가능한 익명 파이프
            <ul>
              <li>양방향 통신을 위해서는 두개의 파이프 (read - write)전용 파이프를 만들어야 한다</li>
            </ul>
          </li>
          <li>양방향 통신이 가능한 명명 파이프</li>
        </ul>
      </li>
      <li>
        <p>공유 메모리 사용</p>

        <ul>
          <li>파이프만으로 해결할 수 없는 경우 사용</li>
          <li>동시성 문제를 주의해야 함</li>
        </ul>
      </li>
    </ul>

    <p>또는 네트워크 통신 방식인</p>

    <ul>
      <li>소켓 통신</li>
      <li>RPC
        <ul>
          <li>Remote Procedure Call
            <ul>
              <li>클라이언트에서 서버에 위치한 프로시저를 호출할 수 있게 하는 프로토콜</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <p>등이 있습니다.</p>

  </div></details>

<details><summary>프로세스 스케쥴링 알고리즘에는 뭐가 있나요?</summary><div>

    <ul>
      <li>
        <p>가장 단순한 FIFO부터 설명드리겠습니다.
먼저 들어온 작업이 먼저 끝나는 형식의 FIFO는 단순하지만, Convoy Effect라는<br />
오래 걸리는 프로세스가 앞에서 점유하고 있을 경우, 뒤 작업들의 처리시간이 늘어나는 문제가 있습니다.<br />
이것을 극복하기 위해서 Shortest Job First 라는 가장 짧은 시간이 걸리는 프로세스를 먼저 처리하는<br />
방법이 존재하지만 역시 starvation 문제가 있습니다.</p>
      </li>
      <li>
        <p>이 문제들을 해결하기 위해서 프로세스를 중간에 가로채는 선점 스케쥴링 방식이 등장합니다.<br />
예시로 Round robin이 있지만, 이 경우 또한 Context Switching 비용을 신경써야 합니다.</p>
      </li>
    </ul>

  </div></details>

<details><summary>데드락에 대해서 설명해주세요</summary><div>

    <ul>
      <li>두개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 못하는 상태를 의미합니다.<br />
예를 들어 A와 B가 두개의 종이에 쓰여 있는 숫자 두개를 더하고 싶을 때,<br />
A가 종이1을 얻고 B가 종이2를 얻었을 때 서로 다른 종이를 얻기 위해 기다리는 상황입니다.</li>
    </ul>

  </div></details>

<details><summary>경쟁 상태에 대해서 설명해주세요</summary><div>

    <ul>
      <li>공유 자원에 대해서 두개 이상의 프로세스나 스레드가 접근할 때 생길 수 있는 문제를 의미합니다.
덧셈 코드가 load/add/store로 나뉘어 있는것을 생각하면 설명하기 좋습니다.<br />
경쟁 상태를 해결할 수 있는 방법으로 Mutual Exclusion이 있는데, 이것은 데드락의 발생조건 중 하나입니다.</li>
    </ul>

  </div></details>

<details><summary>Mutex와 Semaphore</summary><div>

    <ul>
      <li>경쟁상태를 해결하기 위해서 일종의 락을 데이터에 걸어주는 것입니다.<br />
화장실과 화장실 키를 생각해볼 수 있습니다.<br />
하나의 프로세스가 Mutex를 보유했을 때, 다른 프로세스는 접근할 수 없습니다.<br />
세마포어는 이것의 확장입니다.<br />
P(S)로 Semaphore를 감소시키면 busy waiting 하거나 대기 큐로 옮기고
V(S)로 Semaphore를 증가시키면 대기 큐에서 P를 꺼내 실행시킵니다</li>
    </ul>

  </div></details>

<hr />

<h1 id="파일-시스템">파일 시스템</h1>

<details><summary>파일 시스템이란 무엇인가요?</summary><div>

    <ul>
      <li>디스크에 접근하는것을 OS 레벨에서 추상화한 것입니다.</li>
    </ul>

  </div></details>

<details><summary>프로세스에서 파일을 어떻게 읽나요?</summary><div>

    <ul>
      <li>디스크에 접근하는것을 OS 레벨에서 추상화한 것입니다.</li>
    </ul>

    <ol>
      <li>파일 열람을 위한 시스템 콜이 호출됩니다.</li>
    </ol>

    <ul>
      <li>파일의 경로와 읽기 모드를 명시하면 운영체제에서 파일 open 시스템 콜을 호출합니다.</li>
      <li>파일을 성공적으로 읽었을 경우, file descriptor 가 반환됩니다.
        <ul>
          <li>file descriptor란 현재 열려있는 파일의 식별자로 사용되는 정수값입니다.</li>
        </ul>
      </li>
      <li>파일 내용을 읽기 위해서 read 시스템 콜이 호출됩니다.<br />
읽은 내용은 버퍼로 옮겨집니다.</li>
      <li>파일 시스템을 통해서 저장장치에 있는 정보를 읽고, 프로세스의 메모리로 복사됩니다.</li>
      <li>읽은 파일의 총 바이트 수를 반환합니다.</li>
      <li>close 시스템 콜을 날려 파일을 닫습니다.</li>
    </ul>

  </div></details>

<hr />

<h1 id="페이지">페이지</h1>

<details><summary>페이징이 왜 필요한가요?</summary><div>

  </div></details>
 
      </section>

      <footer class="page__meta">
         
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 태그: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#%EB%A9%B4%EC%A0%91" class="page__taxonomy-item p-category" rel="tag">면접</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 카테고리: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#interview" class="page__taxonomy-item p-category" rel="tag">Interview</a>
    
    </span>
  </p>

 

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 업데이트:</strong> <time class="dt-published" datetime="2024-01-24T12:00:00+09:00">January 24, 2024</time></p>

      </footer>
      
  <nav class="pagination">
    
      <a href="/interview/ms_oop1/" class="pagination--pager" title="CS 면접대비 - 객체지향 프로그래밍
">이전</a>
    
    
      <a href="/jpa/persistance/" class="pagination--pager" title="영속성 핥아보기
">다음</a>
    
  </nav>

    </div>

    
  </article>

   
  <div class="page__related">
    <h2 class="page__related-title">
      참고
    </h2>
    <div class="grid__wrapper">
       



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/concurrency/" rel="permalink">티케팅 시스템 구현에서의 동시성 문제 : 원인
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> April 02 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">개요
</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/architecture/" rel="permalink">스프링 코드 아키텍처
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> March 25 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">작성자 : Claycat

개요

여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?

이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다.
프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요.
결정 과정에 대해서 소개해...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/isp1/" rel="permalink">인터페이스 분리 원칙에 대해
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">다 알고 있는 사실

  어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다
자신이 사용하는 메서드에만 의존해야 한다


매번 나오는 설명입니다.
보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.

interface Person {
	public void ...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/jpa/persistance2/" rel="permalink">영속성 까보기 (feat. 10분 테코톡)
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">JPA와 영속성

JPA 영속성 관련 실험 중 이상한 케이스를 발견했습니다.
우아한형제들 테코톡의 문제상황 1에서도 비슷한 예제가 있습니다.
영상에서는 정확히 이유를 설명하지는 않고 영속성 설명으로 넘어가버려서
정확한 이유를 정리해보려고 합니다.

@Getter
@Entity
@A...</p>
  </article>
</div>
 
    </div>
  </div>
   
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력하세요..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>팔로우:</strong></li>
    

    
      
        
          <li><a href="https://github.com/claycat" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Claycat. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', 'claycat');
    script.setAttribute('data-repo-id', 'R_kgDOLLYTXw');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOLLYTX84Ccyz5');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>
  





  </body>
</html>
