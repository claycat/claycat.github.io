<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>CS 면접대비 - 컨테이너 : Claycat</title>
<meta name="description" content="도커가 왜 필요할까요?            옛날 이야기를 잠깐 하면                    옛날에는 서버를 관리하는게 쉽지 않았습니다           새롭게 설치해야하는 프로그램은 많고           운영체제는 업데이트되고           그와중 프로그램끼리 호환이 안되는 경우도 많고           지금 당장 리눅스에 MySQL을 까는건 쉽지 않습니다           이런 문제들을 해결해보기 위해서 VM이라는게 먼저 나왔습니다.                          그렇다면 VM은 뭔가요?                      동일한 하드웨어에서 여러개의 운영체제 인스턴스를 돌려보자 라는 의도의 결과입니다.                     마치 냉장고 안에 냉장고를 넣듯이, 서로 완벽하게 격리되어있고 OS 정보들을 모두 보유하고 있습니다.           각 VM은 호스트로부터 Hypervisor를 통해서 가상 하드웨어와 어댑터를 할당받아서 실제 여러개의 하드웨어가 없더라도 공유할 수 있도록 합니다.           윈도우에서 C드라이브의 Windows 폴더 전체                   그렇다면 VM으로 말씀하신 내용을 다 커버할 수 있는거 아닌가요?                             물론 가능은 합니다만, VM에는 비효율성이 몇가지 있습니다.                                    운영체제 파일 자체를 요구하기 때문에 고정된 하드디스크 요구량과 메모리                   시작하는데 OS별 부팅과정을 거치기 때문에 오래 걸리고                   별도의 커널/라이브러리/바이너리가 다 필요하기때문에 리소스를 많이 먹습니다                                                                사람들은 이 발상을 하게 됩니다 : 굳이 별도의 커널과 OS로 다른 어플리케이션을 실행해야 할까?                                     따라서 도커가 등장합니다                   도커는 일종의 VM으로 리눅스 커널을 이용하여 하위 컨테이너들을 분리합니다.                                   도커는 일종의 VM? 맞나요?                                                                     VirtualBox나 VMWare같은 VM이라기보다는, 도커 엔진이 가상화된 리눅스 환경을 구현해줍니다.     - 윈도우같은경우에는 내장되어있는 hyper-v를 사용합니다.     - 맥의 경우에도 리눅스 커널을 에뮬레이팅 해주는 애플리케이션을 사용합니다. HyperKit                          컨테이너는 매번 OS파일들을 보유할 필요가 없습니다.                                                     마치 냉장고에 야채칸, 계란칸, 김치칸 칸막이를 만드는 것처럼 입니다.                                                                                                           도커는 어떻게 그러면 프로세스를 격리하나요?                                            제가 알고있는바로는 리눅스의 Cgroup과 namespace 기능을 활용하는것으로 알고있습니다.                                                                                                 도커는 그럼 어떻게 그런 운영체제의 버전이나, 다양한 운영체제의 종류를 적은 용량을 통해 저장하나요?             Aufs라는 특별한 파일 시스템을 사용하고, 해당 도커파일을 빌드해서 사용합니다.">



<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="Claycat">
<meta property="og:title" content="CS 면접대비 - 컨테이너">
<meta property="og:url" content="http://localhost:4000/interview/ms_container/">


  <meta property="og:description" content="도커가 왜 필요할까요?            옛날 이야기를 잠깐 하면                    옛날에는 서버를 관리하는게 쉽지 않았습니다           새롭게 설치해야하는 프로그램은 많고           운영체제는 업데이트되고           그와중 프로그램끼리 호환이 안되는 경우도 많고           지금 당장 리눅스에 MySQL을 까는건 쉽지 않습니다           이런 문제들을 해결해보기 위해서 VM이라는게 먼저 나왔습니다.                          그렇다면 VM은 뭔가요?                      동일한 하드웨어에서 여러개의 운영체제 인스턴스를 돌려보자 라는 의도의 결과입니다.                     마치 냉장고 안에 냉장고를 넣듯이, 서로 완벽하게 격리되어있고 OS 정보들을 모두 보유하고 있습니다.           각 VM은 호스트로부터 Hypervisor를 통해서 가상 하드웨어와 어댑터를 할당받아서 실제 여러개의 하드웨어가 없더라도 공유할 수 있도록 합니다.           윈도우에서 C드라이브의 Windows 폴더 전체                   그렇다면 VM으로 말씀하신 내용을 다 커버할 수 있는거 아닌가요?                             물론 가능은 합니다만, VM에는 비효율성이 몇가지 있습니다.                                    운영체제 파일 자체를 요구하기 때문에 고정된 하드디스크 요구량과 메모리                   시작하는데 OS별 부팅과정을 거치기 때문에 오래 걸리고                   별도의 커널/라이브러리/바이너리가 다 필요하기때문에 리소스를 많이 먹습니다                                                                사람들은 이 발상을 하게 됩니다 : 굳이 별도의 커널과 OS로 다른 어플리케이션을 실행해야 할까?                                     따라서 도커가 등장합니다                   도커는 일종의 VM으로 리눅스 커널을 이용하여 하위 컨테이너들을 분리합니다.                                   도커는 일종의 VM? 맞나요?                                                                     VirtualBox나 VMWare같은 VM이라기보다는, 도커 엔진이 가상화된 리눅스 환경을 구현해줍니다.     - 윈도우같은경우에는 내장되어있는 hyper-v를 사용합니다.     - 맥의 경우에도 리눅스 커널을 에뮬레이팅 해주는 애플리케이션을 사용합니다. HyperKit                          컨테이너는 매번 OS파일들을 보유할 필요가 없습니다.                                                     마치 냉장고에 야채칸, 계란칸, 김치칸 칸막이를 만드는 것처럼 입니다.                                                                                                           도커는 어떻게 그러면 프로세스를 격리하나요?                                            제가 알고있는바로는 리눅스의 Cgroup과 namespace 기능을 활용하는것으로 알고있습니다.                                                                                                 도커는 그럼 어떻게 그런 운영체제의 버전이나, 다양한 운영체제의 종류를 적은 용량을 통해 저장하나요?             Aufs라는 특별한 파일 시스템을 사용하고, 해당 도커파일을 빌드해서 사용합니다.">







  <meta property="article:published_time" content="2024-02-24T12:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/interview/ms_container/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Claycat",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Claycat Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->



<link
  rel="apple-touch-icon"
  sizes="180x180"
  href="/assets/images/favicons/apple-touch-icon.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="32x32"
  href="/assets/images/favicons/favicon-32x32.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="16x16"
  href="/assets/images/favicons/favicon-16x16.png"
/>

<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico" />
<meta name="apple-mobile-web-app-title" content="Claycat" />
<meta name="application-name" content="Claycat" />
<meta name="msapplication-TileColor" content="#da532c" />
<meta
  name="msapplication-config"
  content="/assets/images/favicons/browserconfig.xml"
/>
<meta name="theme-color" content="#ffffff" />

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Claycat
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
         

<div id="main" role="main">
  


  <article
    class="page h-entry"
    itemscope
    itemtype="https://schema.org/CreativeWork"
  >
    <meta
      itemprop="headline"
      content="CS 면접대비 - 컨테이너"
    /> <meta
      itemprop="description"
      content="도커가 왜 필요할까요?          옛날 이야기를 잠깐 하면                  옛날에는 서버를 관리하는게 쉽지 않았습니다          새롭게 설치해야하는 프로그램은 많고          운영체제는 업데이트되고          그와중 프로그램끼리 호환이 안되는 경우도 많고          지금 당장 리눅스에 MySQL을 까는건 쉽지 않습니다          이런 문제들을 해결해보기 위해서 VM이라는게 먼저 나왔습니다.                    그렇다면 VM은 뭔가요?                  동일한 하드웨어에서 여러개의 운영체제 인스턴스를 돌려보자 라는 의도의 결과입니다.                  마치 냉장고 안에 냉장고를 넣듯이, 서로 완벽하게 격리되어있고 OS 정보들을 모두 보유하고 있습니다.          각 VM은 호스트로부터 Hypervisor를 통해서 가상 하드웨어와 어댑터를 할당받아서실제 여러개의 하드웨어가 없더라도 공유할 수 있도록 합니다.          윈도우에서 C드라이브의 Windows 폴더 전체                그렇다면 VM으로 말씀하신 내용을 다 커버할 수 있는거 아닌가요?                          물론 가능은 합니다만, VM에는 비효율성이 몇가지 있습니다.                                  운영체제 파일 자체를 요구하기 때문에 고정된 하드디스크 요구량과 메모리                  시작하는데 OS별 부팅과정을 거치기 때문에 오래 걸리고                  별도의 커널/라이브러리/바이너리가 다 필요하기때문에 리소스를 많이 먹습니다                                                            사람들은 이 발상을 하게 됩니다 : 굳이 별도의 커널과 OS로 다른 어플리케이션을 실행해야 할까?                                  따라서 도커가 등장합니다                  도커는 일종의 VM으로 리눅스 커널을 이용하여 하위 컨테이너들을 분리합니다.                                도커는 일종의 VM? 맞나요?                                                                  VirtualBox나 VMWare같은 VM이라기보다는, 도커 엔진이 가상화된 리눅스 환경을 구현해줍니다.    - 윈도우같은경우에는 내장되어있는 hyper-v를 사용합니다.    - 맥의 경우에도 리눅스 커널을 에뮬레이팅 해주는 애플리케이션을 사용합니다. HyperKit                        컨테이너는 매번 OS파일들을 보유할 필요가 없습니다.                                                  마치 냉장고에 야채칸, 계란칸, 김치칸 칸막이를 만드는 것처럼 입니다.                                                                                                    도커는 어떻게 그러면 프로세스를 격리하나요?                                          제가 알고있는바로는 리눅스의 Cgroup과 namespace 기능을 활용하는것으로 알고있습니다.                                                                                      도커는 그럼 어떻게 그런 운영체제의 버전이나, 다양한 운영체제의 종류를 적은 용량을 통해 저장하나요?          Aufs라는 특별한 파일 시스템을 사용하고, 해당 도커파일을 빌드해서 사용합니다.      "
    /> <meta
      itemprop="datePublished"
      content="2024-02-24T12:00:00+09:00"
    /> 

    <div class="page__inner-wrap">
      
      <header>
        
        <h1 id="page-title" class="page__title" itemprop="headline">
          <p>CS 면접대비 - 컨테이너</p>

        </h1>
         
      </header>
      

      <section class="page__content e-content" itemprop="text">
         <details><summary>도커가 왜 필요할까요?</summary><div>
    <ul>
      <li>옛날 이야기를 잠깐 하면
        <ul>
          <li>옛날에는 서버를 관리하는게 쉽지 않았습니다</li>
          <li>새롭게 설치해야하는 프로그램은 많고</li>
          <li>운영체제는 업데이트되고</li>
          <li>그와중 프로그램끼리 호환이 안되는 경우도 많고</li>
          <li>지금 당장 리눅스에 MySQL을 까는건 쉽지 않습니다</li>
          <li>이런 문제들을 해결해보기 위해서 VM이라는게 먼저 나왔습니다.</li>
        </ul>
      </li>
    </ul>
  </div></details>

<details><summary>그렇다면 VM은 뭔가요?</summary><div>

    <ul>
      <li>
        <p>동일한 하드웨어에서 여러개의 운영체제 인스턴스를 돌려보자 라는 의도의 결과입니다.</p>

        <ul>
          <li>마치 냉장고 안에 냉장고를 넣듯이, 서로 완벽하게 격리되어있고 OS 정보들을 모두 보유하고 있습니다.</li>
          <li>각 VM은 호스트로부터 Hypervisor를 통해서 가상 하드웨어와 어댑터를 할당받아서
실제 여러개의 하드웨어가 없더라도 공유할 수 있도록 합니다.</li>
          <li>윈도우에서 C드라이브의 Windows 폴더 전체</li>
        </ul>

        <details><summary>그렇다면 VM으로 말씀하신 내용을 다 커버할 수 있는거 아닌가요?</summary><div>

            <ul>
              <li>물론 가능은 합니다만, VM에는 비효율성이 몇가지 있습니다.
                <ul>
                  <li>운영체제 파일 자체를 요구하기 때문에 고정된 하드디스크 요구량과 메모리</li>
                  <li>시작하는데 OS별 부팅과정을 거치기 때문에 오래 걸리고</li>
                  <li>별도의 커널/라이브러리/바이너리가 다 필요하기때문에 리소스를 많이 먹습니다</li>
                </ul>
              </li>
              <li>
                <p>사람들은 이 발상을 하게 됩니다 : 굳이 별도의 커널과 OS로 다른 어플리케이션을 실행해야 할까?</p>

                <ul>
                  <li>따라서 도커가 등장합니다</li>
                  <li>도커는 일종의 VM으로 리눅스 커널을 이용하여 하위 컨테이너들을 분리합니다.</li>
                </ul>

                <details><summary>도커는 일종의 VM? 맞나요?</summary><div>
                    <ul>
                      <li>
                        <p>VirtualBox나 VMWare같은 VM이라기보다는, 도커 엔진이 가상화된 리눅스 환경을 구현해줍니다.
    - 윈도우같은경우에는 내장되어있는 hyper-v를 사용합니다.
    - 맥의 경우에도 리눅스 커널을 에뮬레이팅 해주는 애플리케이션을 사용합니다. HyperKit</p>

                        <p>컨테이너는 매번 OS파일들을 보유할 필요가 없습니다.</p>

                        <ul>
                          <li>마치 냉장고에 야채칸, 계란칸, 김치칸 칸막이를 만드는 것처럼 입니다.</li>
                        </ul>
                      </li>
                    </ul>

                  </div></details>

                <details><summary>도커는 어떻게 그러면 프로세스를 격리하나요?</summary><div>
                    <ul>
                      <li>제가 알고있는바로는 리눅스의 Cgroup과 namespace 기능을 활용하는것으로 알고있습니다.</li>
                    </ul>
                  </div></details>
              </li>
            </ul>

          </div></details>
      </li>
    </ul>
  </div></details>

<details><summary>도커는 그럼 어떻게 그런 운영체제의 버전이나, 다양한 운영체제의 종류를 적은 용량을 통해 저장하나요?</summary><div>

    <ul>
      <li>Aufs라는 특별한 파일 시스템을 사용하고, 해당 도커파일을 빌드해서 사용합니다.</li>
    </ul>

  </div></details>
 
      </section>

      <footer class="page__meta">
         
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 태그: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#%EB%A9%B4%EC%A0%91" class="page__taxonomy-item p-category" rel="tag">면접</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 카테고리: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#interview" class="page__taxonomy-item p-category" rel="tag">Interview</a>
    
    </span>
  </p>

 

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 업데이트:</strong> <time class="dt-published" datetime="2024-02-24T12:00:00+09:00">February 24, 2024</time></p>

      </footer>
      
  <nav class="pagination">
    
      <a href="/web_servers/" class="pagination--pager" title="웹 서버와 포트, 소켓, 그리고 스레드
">이전</a>
    
    
      <a href="/interview/ms_java1/" class="pagination--pager" title="CS 면접대비 - 프로그래밍 언어(자바)
">다음</a>
    
  </nav>

    </div>

    
  </article>

   
  <div class="page__related">
    <h2 class="page__related-title">
      참고
    </h2>
    <div class="grid__wrapper">
       



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/concurrency/" rel="permalink">티케팅 시스템 구현에서의 동시성 문제 : 원인
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> April 02 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">개요
</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/architecture/" rel="permalink">스프링 코드 아키텍처
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> March 25 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">작성자 : Claycat

개요

여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?

이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다.
프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요.
결정 과정에 대해서 소개해...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/isp1/" rel="permalink">인터페이스 분리 원칙에 대해
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">다 알고 있는 사실

  어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다
자신이 사용하는 메서드에만 의존해야 한다


매번 나오는 설명입니다.
보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.

interface Person {
	public void ...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/jpa/persistance2/" rel="permalink">영속성 까보기 (feat. 10분 테코톡)
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">JPA와 영속성

JPA 영속성 관련 실험 중 이상한 케이스를 발견했습니다.
우아한형제들 테코톡의 문제상황 1에서도 비슷한 예제가 있습니다.
영상에서는 정확히 이유를 설명하지는 않고 영속성 설명으로 넘어가버려서
정확한 이유를 정리해보려고 합니다.

@Getter
@Entity
@A...</p>
  </article>
</div>
 
    </div>
  </div>
   
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력하세요..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>팔로우:</strong></li>
    

    
      
        
          <li><a href="https://github.com/claycat" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Claycat. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', 'claycat');
    script.setAttribute('data-repo-id', 'R_kgDOLLYTXw');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOLLYTX84Ccyz5');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>
  





  </body>
</html>
