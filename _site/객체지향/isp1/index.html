<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>인터페이스 분리 원칙에 대해 : Claycat</title>
<meta name="description" content="다 알고 있는 사실    어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다 자신이 사용하는 메서드에만 의존해야 한다   매번 나오는 설명입니다. 보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.  interface Person { 	public void work(); 	public void eat(); 	public void play(); }  class SomePerson implements Person{ 	public void work() {         ... 	} 	public void eat() {         ... 	} 	public void play() { 		... 	} }  class VeganPerson implements Person{ 	public void work() {         ... 	}  	public void eat() {         ... 	} 	public void play() { 		... 	} }  하지만 eat 메소드가 필요 없는 Worker가 등장할 경우  예외 처리를 하거나 의미없는 반환값 등으로 구현을 해야합니다.  따라서  interface Workable { 	public void work(); }  interface Feedable{ 	public void eat(); }  interface Playable{ 	public void eat(); }  class Person implements Workable, Feedable, Playable{ 	public void work() { 		... 	}  	public void eat() { 		... 	}  	public void play() { 		... 	} }   이렇게 짜라고 알려져 있습니다.  근데 왜? ISP를 준수하면 얻는것이 무엇인가?     변경에 대해서 유연한 것 ?   불필요한 책임 제거 ?   확장성 향상?   이것들은 SRP나 다형성에 대한 것들이지, ISP와는 거리가 있다고 생각합니다.  의존하는 모듈을 생각하라 앞서 언급된 설명은 클래스에 구현에 초점이 맞춰져 있습니다. 하지만 ISP의 의의는 의존관계에 있다고 생각합니다. 클래스의 의존관계의 측면에서 ISP를 준수하지 않는 경우를 살펴보도록 합시다.    하나의 클래스에 모듈 A,B,C에 필요한 메소드들이 모두 선언되어있습니다 여기서 문제는 모듈 A가 자신이 사용하지 않는 메소드 (2,3,5,6)을 호출하는것을 막지 못한다는것입니다. 모듈 B와 C도 마찬가지입니다.  다시 이전 코드 예시로 돌아가겠습니다. ISP 를 준수하지 않은 Worker 인터페이스를 의존하는 모듈을 가정해봅시다.  class WorkPlace { 	private List&lt;Person&gt; workers;  	public void addWorker(Person worker) { 		workers.add(worker); 	}  	public void allWork() { 		for(Person worker : workers) { 			worker.work(); 		}  		//troll 		worker.play(); 	} }   WorkPlace 클래스 내부에서 Worker을 직접적으로 의존하게되면 다른 메소드를 호출하는것이 가능해져버립니다.  이 문제를 해결하는 방법은 두가지가 존재합니다.  소유 모델  class Person { 	private Workable work; 	private Playable play; 	private Eatable eat; }  이후 각 모듈들은 Person이 소유하는 내부 객체만을 바라보면서 소통할 수 있습니다.  인터페이스 모델  interface Person extends Workable, Playable, Eatable { 	 }  마찬가지로 외부 모듈들은 Workable, Playable, Eatable을 골라서 협력하는것이 가능합니다.  결과 위 두 방법을 사용하여 인터페이스에 의존한다면 컴파일 타임에 막을 수 있습니다.  class WorkPlace { 	private List&lt;IWork&gt; workers;  	public void addWorker(Workable worker) { 		workers.add(worker); 	}  	public void allWork() { 		for(Workable worker : workers) { 			worker.work(); 		}  		//doesn&#39;t compile 		worker.play(); 	} }   즉 ISP를 만족시킨다면 인터페이스에 대한 접근권한을 컴파일 시간에 타입으로 막을 수 있는 것입니다.  감사합니다.  Credits 모든 내용은 유튜브 코드스피츠 채널 을 참고하였습니다">



<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="Claycat">
<meta property="og:title" content="인터페이스 분리 원칙에 대해">
<meta property="og:url" content="http://localhost:4000/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/isp1/">


  <meta property="og:description" content="다 알고 있는 사실    어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다 자신이 사용하는 메서드에만 의존해야 한다   매번 나오는 설명입니다. 보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.  interface Person { 	public void work(); 	public void eat(); 	public void play(); }  class SomePerson implements Person{ 	public void work() {         ... 	} 	public void eat() {         ... 	} 	public void play() { 		... 	} }  class VeganPerson implements Person{ 	public void work() {         ... 	}  	public void eat() {         ... 	} 	public void play() { 		... 	} }  하지만 eat 메소드가 필요 없는 Worker가 등장할 경우  예외 처리를 하거나 의미없는 반환값 등으로 구현을 해야합니다.  따라서  interface Workable { 	public void work(); }  interface Feedable{ 	public void eat(); }  interface Playable{ 	public void eat(); }  class Person implements Workable, Feedable, Playable{ 	public void work() { 		... 	}  	public void eat() { 		... 	}  	public void play() { 		... 	} }   이렇게 짜라고 알려져 있습니다.  근데 왜? ISP를 준수하면 얻는것이 무엇인가?     변경에 대해서 유연한 것 ?   불필요한 책임 제거 ?   확장성 향상?   이것들은 SRP나 다형성에 대한 것들이지, ISP와는 거리가 있다고 생각합니다.  의존하는 모듈을 생각하라 앞서 언급된 설명은 클래스에 구현에 초점이 맞춰져 있습니다. 하지만 ISP의 의의는 의존관계에 있다고 생각합니다. 클래스의 의존관계의 측면에서 ISP를 준수하지 않는 경우를 살펴보도록 합시다.    하나의 클래스에 모듈 A,B,C에 필요한 메소드들이 모두 선언되어있습니다 여기서 문제는 모듈 A가 자신이 사용하지 않는 메소드 (2,3,5,6)을 호출하는것을 막지 못한다는것입니다. 모듈 B와 C도 마찬가지입니다.  다시 이전 코드 예시로 돌아가겠습니다. ISP 를 준수하지 않은 Worker 인터페이스를 의존하는 모듈을 가정해봅시다.  class WorkPlace { 	private List&lt;Person&gt; workers;  	public void addWorker(Person worker) { 		workers.add(worker); 	}  	public void allWork() { 		for(Person worker : workers) { 			worker.work(); 		}  		//troll 		worker.play(); 	} }   WorkPlace 클래스 내부에서 Worker을 직접적으로 의존하게되면 다른 메소드를 호출하는것이 가능해져버립니다.  이 문제를 해결하는 방법은 두가지가 존재합니다.  소유 모델  class Person { 	private Workable work; 	private Playable play; 	private Eatable eat; }  이후 각 모듈들은 Person이 소유하는 내부 객체만을 바라보면서 소통할 수 있습니다.  인터페이스 모델  interface Person extends Workable, Playable, Eatable { 	 }  마찬가지로 외부 모듈들은 Workable, Playable, Eatable을 골라서 협력하는것이 가능합니다.  결과 위 두 방법을 사용하여 인터페이스에 의존한다면 컴파일 타임에 막을 수 있습니다.  class WorkPlace { 	private List&lt;IWork&gt; workers;  	public void addWorker(Workable worker) { 		workers.add(worker); 	}  	public void allWork() { 		for(Workable worker : workers) { 			worker.work(); 		}  		//doesn&#39;t compile 		worker.play(); 	} }   즉 ISP를 만족시킨다면 인터페이스에 대한 접근권한을 컴파일 시간에 타입으로 막을 수 있는 것입니다.  감사합니다.  Credits 모든 내용은 유튜브 코드스피츠 채널 을 참고하였습니다">







  <meta property="article:published_time" content="2024-02-27T12:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/isp1/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Claycat",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Claycat Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->



<link
  rel="apple-touch-icon"
  sizes="180x180"
  href="/assets/images/favicons/apple-touch-icon.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="32x32"
  href="/assets/images/favicons/favicon-32x32.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="16x16"
  href="/assets/images/favicons/favicon-16x16.png"
/>

<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico" />
<meta name="apple-mobile-web-app-title" content="Claycat" />
<meta name="application-name" content="Claycat" />
<meta name="msapplication-TileColor" content="#da532c" />
<meta
  name="msapplication-config"
  content="/assets/images/favicons/browserconfig.xml"
/>
<meta name="theme-color" content="#ffffff" />

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Claycat
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
         

<div id="main" role="main">
  


  <article
    class="page h-entry"
    itemscope
    itemtype="https://schema.org/CreativeWork"
  >
    <meta
      itemprop="headline"
      content="인터페이스 분리 원칙에 대해"
    /> <meta
      itemprop="description"
      content="다 알고 있는 사실  어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다자신이 사용하는 메서드에만 의존해야 한다매번 나오는 설명입니다.보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.interface Person {	public void work();	public void eat();	public void play();}class SomePerson implements Person{	public void work() {        ...	}	public void eat() {        ...	}	public void play() {		...	}}class VeganPerson implements Person{	public void work() {        ...	}	public void eat() {        ...	}	public void play() {		...	}}하지만 eat 메소드가 필요 없는 Worker가 등장할 경우 예외 처리를 하거나 의미없는 반환값 등으로 구현을 해야합니다.따라서interface Workable {	public void work();}interface Feedable{	public void eat();}interface Playable{	public void eat();}class Person implements Workable, Feedable, Playable{	public void work() {		...	}	public void eat() {		...	}	public void play() {		...	}}이렇게 짜라고 알려져 있습니다.근데 왜?ISP를 준수하면 얻는것이 무엇인가?  변경에 대해서 유연한 것 ?  불필요한 책임 제거 ?  확장성 향상?이것들은 SRP나 다형성에 대한 것들이지, ISP와는 거리가 있다고 생각합니다.의존하는 모듈을 생각하라앞서 언급된 설명은 클래스에 구현에 초점이 맞춰져 있습니다.하지만 ISP의 의의는 의존관계에 있다고 생각합니다.클래스의 의존관계의 측면에서 ISP를 준수하지 않는 경우를 살펴보도록 합시다.하나의 클래스에 모듈 A,B,C에 필요한 메소드들이 모두 선언되어있습니다여기서 문제는 모듈 A가 자신이 사용하지 않는 메소드 (2,3,5,6)을 호출하는것을 막지 못한다는것입니다.모듈 B와 C도 마찬가지입니다.다시 이전 코드 예시로 돌아가겠습니다.ISP 를 준수하지 않은 Worker 인터페이스를 의존하는 모듈을 가정해봅시다.class WorkPlace {	private List&lt;Person&gt; workers;	public void addWorker(Person worker) {		workers.add(worker);	}	public void allWork() {		for(Person worker : workers) {			worker.work();		}		//troll		worker.play();	}}WorkPlace 클래스 내부에서 Worker을 직접적으로 의존하게되면 다른 메소드를 호출하는것이 가능해져버립니다.이 문제를 해결하는 방법은 두가지가 존재합니다.소유 모델class Person {	private Workable work;	private Playable play;	private Eatable eat;}이후 각 모듈들은 Person이 소유하는 내부 객체만을 바라보면서 소통할 수 있습니다.인터페이스 모델interface Person extends Workable, Playable, Eatable {	}마찬가지로 외부 모듈들은 Workable, Playable, Eatable을 골라서 협력하는것이 가능합니다.결과위 두 방법을 사용하여 인터페이스에 의존한다면 컴파일 타임에 막을 수 있습니다.class WorkPlace {	private List&lt;IWork&gt; workers;	public void addWorker(Workable worker) {		workers.add(worker);	}	public void allWork() {		for(Workable worker : workers) {			worker.work();		}		//doesn&#39;t compile		worker.play();	}}즉 ISP를 만족시킨다면 인터페이스에 대한 접근권한을 컴파일 시간에 타입으로 막을 수 있는 것입니다.감사합니다.Credits모든 내용은 유튜브 코드스피츠 채널 을 참고하였습니다"
    /> <meta
      itemprop="datePublished"
      content="2024-02-27T12:00:00+09:00"
    /> 

    <div class="page__inner-wrap">
      
      <header>
        
        <h1 id="page-title" class="page__title" itemprop="headline">
          <p>인터페이스 분리 원칙에 대해</p>

        </h1>
         
      </header>
      

      <section class="page__content e-content" itemprop="text">
         <h2 id="다-알고-있는-사실"><strong>다 알고 있는 사실</strong></h2>
<blockquote>
  <p>어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다<br />
자신이 사용하는 메서드에만 의존해야 한다</p>
</blockquote>

<p>매번 나오는 설명입니다.<br />
보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">();</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">SomePerson</span> <span class="kd">implements</span> <span class="nc">Person</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">VeganPerson</span> <span class="kd">implements</span> <span class="nc">Person</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>하지만 eat 메소드가 필요 없는 Worker가 등장할 경우 
예외 처리를 하거나 의미없는 반환값 등으로 구현을 해야합니다.</p>

<p>따라서</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Workable</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Feedable</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Playable</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="nc">Workable</span><span class="o">,</span> <span class="nc">Feedable</span><span class="o">,</span> <span class="nc">Playable</span><span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 짜라고 알려져 있습니다.</p>

<h2 id="근데-왜"><strong>근데 왜?</strong></h2>
<p><strong>ISP를 준수하면 얻는것이 무엇인가?</strong></p>

<ul>
  <li>변경에 대해서 유연한 것 ?</li>
  <li>불필요한 책임 제거 ?</li>
  <li>확장성 향상?</li>
</ul>

<p>이것들은 SRP나 다형성에 대한 것들이지, ISP와는 거리가 있다고 생각합니다.</p>

<h2 id="의존하는-모듈을-생각하라"><strong>의존하는 모듈을 생각하라</strong></h2>
<p>앞서 언급된 설명은 클래스에 구현에 초점이 맞춰져 있습니다.<br />
하지만 ISP의 의의는 의존관계에 있다고 생각합니다.<br />
클래스의 의존관계의 측면에서 ISP를 준수하지 않는 경우를 살펴보도록 합시다.</p>

<p><img src="/assets/img/posts/bad_isp.png" alt="alt text" /></p>

<p>하나의 클래스에 모듈 A,B,C에 필요한 메소드들이 모두 선언되어있습니다<br />
<strong>여기서 문제는 모듈 A가 자신이 사용하지 않는 메소드 (2,3,5,6)을 호출하는것을 막지 못한다는것입니다.</strong><br />
모듈 B와 C도 마찬가지입니다.</p>

<p>다시 이전 코드 예시로 돌아가겠습니다.<br />
ISP 를 준수하지 않은 Worker 인터페이스를 의존하는 모듈을 가정해봅시다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">WorkPlace</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">workers</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">addWorker</span><span class="o">(</span><span class="nc">Person</span> <span class="n">worker</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">workers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">worker</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">allWork</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">for</span><span class="o">(</span><span class="nc">Person</span> <span class="n">worker</span> <span class="o">:</span> <span class="n">workers</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">worker</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="c1">//troll</span>
		<span class="n">worker</span><span class="o">.</span><span class="na">play</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>WorkPlace 클래스 내부에서 Worker을 직접적으로 의존하게되면 다른 메소드를 호출하는것이 가능해져버립니다.</p>

<p>이 문제를 해결하는 방법은 두가지가 존재합니다.</p>

<h3 id="소유-모델"><strong>소유 모델</strong></h3>
<p><img src="/assets/img/posts/good_isp1.png" alt="alt text" /></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">Workable</span> <span class="n">work</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">Playable</span> <span class="n">play</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">Eatable</span> <span class="n">eat</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이후 각 모듈들은 Person이 소유하는 내부 객체만을 바라보면서 소통할 수 있습니다.</p>

<h3 id="인터페이스-모델"><strong>인터페이스 모델</strong></h3>
<p><img src="/assets/img/posts/good_isp2.png" alt="alt text" /></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Person</span> <span class="kd">extends</span> <span class="nc">Workable</span><span class="o">,</span> <span class="nc">Playable</span><span class="o">,</span> <span class="nc">Eatable</span> <span class="o">{</span>
	
<span class="o">}</span>
</code></pre></div></div>
<p>마찬가지로 외부 모듈들은 Workable, Playable, Eatable을 골라서 협력하는것이 가능합니다.</p>

<h3 id="결과"><strong>결과</strong></h3>
<p>위 두 방법을 사용하여 인터페이스에 의존한다면 컴파일 타임에 막을 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">WorkPlace</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">IWork</span><span class="o">&gt;</span> <span class="n">workers</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">addWorker</span><span class="o">(</span><span class="nc">Workable</span> <span class="n">worker</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">workers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">worker</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">allWork</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">for</span><span class="o">(</span><span class="nc">Workable</span> <span class="n">worker</span> <span class="o">:</span> <span class="n">workers</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">worker</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="c1">//doesn't compile</span>
		<span class="n">worker</span><span class="o">.</span><span class="na">play</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>즉 ISP를 만족시킨다면 인터페이스에 대한 접근권한을 컴파일 시간에 타입으로 막을 수 있는 것입니다.</strong></p>

<p>감사합니다.</p>

<h2 id="credits">Credits</h2>
<p>모든 내용은 유튜브 <a href="https://www.youtube.com/@CodeSpitz">코드스피츠 채널</a> 을 참고하였습니다</p>
 
      </section>

      <footer class="page__meta">
         
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 태그: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5" class="page__taxonomy-item p-category" rel="tag">객체지향</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 카테고리: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5" class="page__taxonomy-item p-category" rel="tag">객체지향</a>
    
    </span>
  </p>

 

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 업데이트:</strong> <time class="dt-published" datetime="2024-02-27T12:00:00+09:00">February 27, 2024</time></p>

      </footer>
      
  <nav class="pagination">
    
      <a href="/jpa/persistance2/" class="pagination--pager" title="영속성 까보기 (feat. 10분 테코톡)
">이전</a>
    
    
      <a href="/tiketeer/architecture/" class="pagination--pager" title="스프링 코드 아키텍처
">다음</a>
    
  </nav>

    </div>

    
  </article>

   
  <div class="page__related">
    <h2 class="page__related-title">
      참고
    </h2>
    <div class="grid__wrapper">
       



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/concurrency/" rel="permalink">티케팅 시스템 구현에서의 동시성 문제 : 원인
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> April 02 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">개요
</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/architecture/" rel="permalink">스프링 코드 아키텍처
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> March 25 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">작성자 : Claycat

개요

여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?

이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다.
프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요.
결정 과정에 대해서 소개해...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/jpa/persistance2/" rel="permalink">영속성 까보기 (feat. 10분 테코톡)
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">JPA와 영속성

JPA 영속성 관련 실험 중 이상한 케이스를 발견했습니다.
우아한형제들 테코톡의 문제상황 1에서도 비슷한 예제가 있습니다.
영상에서는 정확히 이유를 설명하지는 않고 영속성 설명으로 넘어가버려서
정확한 이유를 정리해보려고 합니다.

@Getter
@Entity
@A...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/interview/ms_java1/" rel="permalink">CS 면접대비 - 프로그래밍 언어(자바)
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 24 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">❓Call by Value 와 Call by reference의 차이가 무엇인가요?
</p>
  </article>
</div>
 
    </div>
  </div>
   
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력하세요..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>팔로우:</strong></li>
    

    
      
        
          <li><a href="https://github.com/claycat" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Claycat. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', 'claycat');
    script.setAttribute('data-repo-id', 'R_kgDOLLYTXw');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOLLYTX84Ccyz5');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>
  





  </body>
</html>
