<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>스프링 코드 아키텍처 : Claycat</title>
<meta name="description" content="작성자 : Claycat  개요  여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?  이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다. 프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요. 결정 과정에 대해서 소개해 보려고 합니다.  해당 프로젝트의 Github 여기 입니다.  서론  이전에 진행했던 프로젝트들은 전통적인 Layered Architecture로 이루어졌습니다.    일반적으로 Controller, Service, Repository 세개의 레이어로 구성되어있습니다. Controller에서는 Service에 의존하고, Service에서는 Repository에 의존하는 방식입니다.  조금 더 구체적인 예시를 들면 다음과 같습니다.    해당 방식은 소규모의 프로젝트에서는 문제가 없었지만, 다양한 유틸리티 메소드와 비즈니스 로직이 많아지고, API 엔드포인트들이 많아질수록 서비스단의 코드가 비대해졌습니다. 서비스 코드가 몇백줄을 넘어가면서 유지보수성은 떨어지고 가독성 또한 낮아졌습니다.  원인  이 문제의 원인은 컨트롤러 - 서비스간의 1:1 관계 때문이라고 분석했습니다. 위 Member 예제처럼 MemberController - MemberService로 연관되어있는 경우입니다. 이 경우, MemberService는 MemberController의 모든 엔드포인트를 메소드로 구현해야 합니다. Member에 대한 모든 비즈니스 로직을 포함할 수 밖에 없고, 거대한 테스트 코드는 덤입니다.  저희는 해당 도메인을 단 하나의 서비스 객체로 나타내는 구조는 거대한 객체를 유발하고, 가독성과 유지보수성이 떨어지며, 객체지향적으로도 너무 많은 책임을 갖는 좋지 않은 구조라고 판단하였습니다.  대안  해당 문제를 어떻게 해결할 수 있을지 회의를 하였고, 몇가지 제안들이 있었습니다.          CrudService             ✋ 비대한 서비스 코드를 줄일 수 있도록 CRUD관련 엔드포인트들만 별도로 처리하는 서비스 객체를 사용하자!                Hexagonal Architecture &amp; Clean Architecture             ✋ 익숙한 계층 아키텍처 대신 새로운 아키텍처를 도입해서 사용하자!                DDD의 아이디어 채용 - UseCase에 중점을 두자             ✋ 꼭 하나의 서비스가 여러개의 엔드포인트를 처리해야 할까? 하나의 엔드포인트에 대한 하나의 서비스(유즈케이스)로서 대응하는건 어떨까?           논의          CrudService             🙆 비대한 서비스 코드의 부담을 일부분 덜어줄 수 있다는 것은 동의.                    🙅 하지만 결국 본질적인 문제를 해결하는것은 아니다.           🙅 CRUD이외의 엔드포인트가 다수 추가된다면 결국 비대해지는것은 마찬가지                                Hexagonal &amp; Clean Architecture             기존 계층구조로 구성된 코드를 모두 뒤엎어야 함                    🙅 참고할 수 있는 정석적인 자료가 부재하며, 참고자료마다 구현방식이 모두 다름                       🙆 Ports &amp; Adapter를 통해 외부 입력과 출력에 대해서 독립성을 확보할 수 있다                    🙅 in/out에 대한 port 및 adapter를 모두 작성해야 하는 불편함이 존재           🙅 사이드 프로젝트의 규모상 웹 요청방식은 HTTP이외가 추가되지 않을 것이며, 마찬가지로 영속성 툴 또한 메인 DB (MySQL)에서 추가되지 않을 것인데, 오버엔지니어링이 아닐까                                UseCase 중심            🙆 익숙한 편이며, 서비스를 잘게 쪼갤 수 있다.       🙅 결국 모든 엔드포인트에 대해서 대응하는 유즈케이스 객체가 만들어질텐데, 너무 많아지지 않을까?                    🙆 어차피 작업중인 유즈케이스만 보게 될 것           🙆 동시에 여러 유즈케이스를 보는 상황이 온다면 의존성 문제가 생긴게 아닐까                           결론  논의 결과, 저희는 UseCase를 중심으로 한, 세분화된 서비스 객체의 계층구조로 결정하였습니다.  결론은 다음과 같습니다.          컨트롤러는 기존과 동일한 역할을 수행하고, 도메인별로 분리합니다.             API 엔드포인트 상                    /members/** -&gt; MemberController           /ticketings/** -&gt; TicketingController                                기존 서비스를 메소드별로 UseCase로 나누어 별도의 객체로 분리합니다.            MemberService 하위의                    memberService.login -&gt; LoginUseCase           memberService.register -&gt; RegisterUseCase           memberService.logout -&gt; LogoutUseCase                           코드를 살펴보면 다음과 같습니다.  //편의상 주입 생략  @RestController @RequestMapping(&quot;/members&quot;) public class MemberController {  	@PostMapping(&quot;/register&quot;) 	public ApiResponse&lt;MemberRegisterResponseDto&gt; registerMember( 		final @Valid @RequestBody MemberRegisterRequestDto registerMemberDto) { 		return ApiResponse.wrap( 			MemberRegisterResponseDto.toDto(memberRegisterUseCase.register(MemberRegisterCommandDto.builder() 				.email(registerMemberDto.getEmail()) 				.isSeller(registerMemberDto.getIsSeller()) 				.build() 			)) 		); 	}  	@PostMapping(path = &quot;/password-reset/mail&quot;) 	public ResponseEntity sendPasswordChangeEmail() { 		var email = securityContextHelper.getEmailInToken(); 		sendPasswordChangeEmailUseCase.sendEmail( 			SendPwdChangeEmailCommandDto.builder().email(email).build()); 		return ResponseEntity.ok().build(); 	}  	@PostMapping(path = &quot;/{memberId}/points&quot;) 	public ResponseEntity&lt;ApiResponse&lt;ChargePointResponseDto&gt;&gt; chargePoint(@PathVariable String memberId, 		@Valid @RequestBody ChargePointRequestDto request) { 		var email = securityContextHelper.getEmailInToken(); 		var totalPoint = chargeMemberPointUseCase.chargePoint(request.convertToCommandDto(memberId, email)) 			.getTotalPoint(); 		var result = ChargePointResponseDto.builder().totalPoint(totalPoint).build(); 		return ResponseEntity.status(HttpStatus.OK).body(ApiResponse.wrap(result)); 	} }   재사용성과 의존성  해당 방식을 논의하던 중, 여러 유즈케이스에서 공통적으로 의존하는 로직이나 모듈에 대한 지적이 있었습니다. 공통적인 로직을 처리할 때는 ***Service라는 네이밍으로 적절한 추상화와 객체지향적 센스를 발휘하여 사용하기로 정하였습니다.  예시를 살펴보면 다음과 같습니다.  구매자의 “구매목록”을 담당하는 Purchase 도메인 내부의 생성 및 삭제 유즈 케이스입니다.  @Service public class CreatePurchaseUseCase {  	@Transactional 	public CreatePurchaseResultDto createPurchase(CreatePurchaseCommandDto command) {          //PurchaseService 		purchaseService.validateTicketingSalePeriod(ticketingId, command.getCommandCreatedAt());  		var newPurchase = purchaseRepository.save(Purchase.builder().member(member).build()); 		var tickets = ticketRepository.findByTicketingIdAndPurchaseIsNullOrderById( 			ticketingId, Limit.of(count));  		if (tickets.size() &lt; count) { 			throw new NotEnoughTicketException(); 		}  		tickets.forEach(ticket -&gt; { 			ticket.setPurchase(newPurchase); 		});  		return CreatePurchaseResultDto.builder() 			.purchaseId(newPurchase.getId()) 			.createdAt(newPurchase.getCreatedAt()) 			.build(); 	} }   @Service public class DeletePurchaseTicketsUseCase {  	@Transactional 	public void deletePurchaseTickets(DeletePurchaseTicketsCommandDto command) { 		var purchase = purchaseRepository.findById(command.getPurchaseId()).orElseThrow( 			PurchaseNotFoundException::new); 		var ticketsUnderPurchase = purchaseService.findTicketsUnderPurchase(purchase.getId()); 		var ticketsToRefund = ticketRepository.findAllById(command.getTicketIds()); 		var ticketing = ticketsUnderPurchase.getFirst().getTicketing();          //PurchaseService 		purchaseService.validatePurchaseOwnership(purchase.getId(), command.getMemberEmail()); 		purchaseService.validateTicketingSalePeriod(ticketing.getId(), command.getCommandCreatedAt());  		var ticketIdUnderPurchase = ticketsUnderPurchase.stream().map(Ticket::getId).toList(); 		AtomicInteger numOfDeletedTicket = new AtomicInteger(); 		ticketsToRefund.forEach(ticket -&gt; { 			if (ticketIdUnderPurchase.contains(ticket.getId())) { 				ticket.setPurchase(null); 				numOfDeletedTicket.getAndIncrement(); 			} 		}); 		if (numOfDeletedTicket.get() == ticketsUnderPurchase.size()) { 			purchaseRepository.delete(purchase); 		} 	} }    두가지 유즈케이스 모두 “구매”에 대한 Validation을 하는 공통 로직에 의존하고 있기 때문에 해당 로직은 PurchaseService에 위임하였습니다.  다이어그램으로 살펴보면 다음과 같습니다.    이를 통해 공통 로직과 의존도를 분리할 수 있었습니다.  후기  개인적으로 더이상 거대한 Service 객체를 보지 않아도 되는 면에서 가독성만큼은 훨씬 낫다고 생각합니다. 하나의 유즈케이스에 대해서만 집중해도 되니 유틸리티 메소드에 대한 의존성 관리도 쾌적해졌다고 느꼈습니다. 이전에 사용하던 계층 구조와 선택하라고 한다면 분명 현재를 고를 것입니다. 다만 우려되거나 아쉬운 부분 또한 존재합니다.  특히 우려되는 점은 서비스에 대한 오염입니다. 적절한 책임의 분리를 하지 않고 모든 유틸리티 메소드들을 밀어넣는 용도로 XXXService를 사용한다면 결국 재사용성이 떨어지는 거대객체가 될 확률이 높습니다.  이 글을 작성하면서 보니, 위 언급된 이미지에서의 PurchaseService 또한 Validation과 Find의 유틸리티 책임이 혼합되어있습니다. PurchaseValidationService와 PurchaseFindService로 쪼개는게 더 적절할 수도 있습니다.  아쉬운 부분은 Hexagonal 과 Clean Architecture, Domain Driven Design등에 대해서 조금 더 깊은 이해를 했거나 경험이 있었다면 더 좋은 아키텍처가 있을 수도 있다는 것이었습니다. 해당 부분은 사이드 프로젝트를 마무리한다면 깊게 한번 다시 탐구해보도록 하겠습니다.  감사합니다.">



<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="Claycat">
<meta property="og:title" content="스프링 코드 아키텍처">
<meta property="og:url" content="http://localhost:4000/tiketeer/architecture/">


  <meta property="og:description" content="작성자 : Claycat  개요  여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?  이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다. 프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요. 결정 과정에 대해서 소개해 보려고 합니다.  해당 프로젝트의 Github 여기 입니다.  서론  이전에 진행했던 프로젝트들은 전통적인 Layered Architecture로 이루어졌습니다.    일반적으로 Controller, Service, Repository 세개의 레이어로 구성되어있습니다. Controller에서는 Service에 의존하고, Service에서는 Repository에 의존하는 방식입니다.  조금 더 구체적인 예시를 들면 다음과 같습니다.    해당 방식은 소규모의 프로젝트에서는 문제가 없었지만, 다양한 유틸리티 메소드와 비즈니스 로직이 많아지고, API 엔드포인트들이 많아질수록 서비스단의 코드가 비대해졌습니다. 서비스 코드가 몇백줄을 넘어가면서 유지보수성은 떨어지고 가독성 또한 낮아졌습니다.  원인  이 문제의 원인은 컨트롤러 - 서비스간의 1:1 관계 때문이라고 분석했습니다. 위 Member 예제처럼 MemberController - MemberService로 연관되어있는 경우입니다. 이 경우, MemberService는 MemberController의 모든 엔드포인트를 메소드로 구현해야 합니다. Member에 대한 모든 비즈니스 로직을 포함할 수 밖에 없고, 거대한 테스트 코드는 덤입니다.  저희는 해당 도메인을 단 하나의 서비스 객체로 나타내는 구조는 거대한 객체를 유발하고, 가독성과 유지보수성이 떨어지며, 객체지향적으로도 너무 많은 책임을 갖는 좋지 않은 구조라고 판단하였습니다.  대안  해당 문제를 어떻게 해결할 수 있을지 회의를 하였고, 몇가지 제안들이 있었습니다.          CrudService             ✋ 비대한 서비스 코드를 줄일 수 있도록 CRUD관련 엔드포인트들만 별도로 처리하는 서비스 객체를 사용하자!                Hexagonal Architecture &amp; Clean Architecture             ✋ 익숙한 계층 아키텍처 대신 새로운 아키텍처를 도입해서 사용하자!                DDD의 아이디어 채용 - UseCase에 중점을 두자             ✋ 꼭 하나의 서비스가 여러개의 엔드포인트를 처리해야 할까? 하나의 엔드포인트에 대한 하나의 서비스(유즈케이스)로서 대응하는건 어떨까?           논의          CrudService             🙆 비대한 서비스 코드의 부담을 일부분 덜어줄 수 있다는 것은 동의.                    🙅 하지만 결국 본질적인 문제를 해결하는것은 아니다.           🙅 CRUD이외의 엔드포인트가 다수 추가된다면 결국 비대해지는것은 마찬가지                                Hexagonal &amp; Clean Architecture             기존 계층구조로 구성된 코드를 모두 뒤엎어야 함                    🙅 참고할 수 있는 정석적인 자료가 부재하며, 참고자료마다 구현방식이 모두 다름                       🙆 Ports &amp; Adapter를 통해 외부 입력과 출력에 대해서 독립성을 확보할 수 있다                    🙅 in/out에 대한 port 및 adapter를 모두 작성해야 하는 불편함이 존재           🙅 사이드 프로젝트의 규모상 웹 요청방식은 HTTP이외가 추가되지 않을 것이며, 마찬가지로 영속성 툴 또한 메인 DB (MySQL)에서 추가되지 않을 것인데, 오버엔지니어링이 아닐까                                UseCase 중심            🙆 익숙한 편이며, 서비스를 잘게 쪼갤 수 있다.       🙅 결국 모든 엔드포인트에 대해서 대응하는 유즈케이스 객체가 만들어질텐데, 너무 많아지지 않을까?                    🙆 어차피 작업중인 유즈케이스만 보게 될 것           🙆 동시에 여러 유즈케이스를 보는 상황이 온다면 의존성 문제가 생긴게 아닐까                           결론  논의 결과, 저희는 UseCase를 중심으로 한, 세분화된 서비스 객체의 계층구조로 결정하였습니다.  결론은 다음과 같습니다.          컨트롤러는 기존과 동일한 역할을 수행하고, 도메인별로 분리합니다.             API 엔드포인트 상                    /members/** -&gt; MemberController           /ticketings/** -&gt; TicketingController                                기존 서비스를 메소드별로 UseCase로 나누어 별도의 객체로 분리합니다.            MemberService 하위의                    memberService.login -&gt; LoginUseCase           memberService.register -&gt; RegisterUseCase           memberService.logout -&gt; LogoutUseCase                           코드를 살펴보면 다음과 같습니다.  //편의상 주입 생략  @RestController @RequestMapping(&quot;/members&quot;) public class MemberController {  	@PostMapping(&quot;/register&quot;) 	public ApiResponse&lt;MemberRegisterResponseDto&gt; registerMember( 		final @Valid @RequestBody MemberRegisterRequestDto registerMemberDto) { 		return ApiResponse.wrap( 			MemberRegisterResponseDto.toDto(memberRegisterUseCase.register(MemberRegisterCommandDto.builder() 				.email(registerMemberDto.getEmail()) 				.isSeller(registerMemberDto.getIsSeller()) 				.build() 			)) 		); 	}  	@PostMapping(path = &quot;/password-reset/mail&quot;) 	public ResponseEntity sendPasswordChangeEmail() { 		var email = securityContextHelper.getEmailInToken(); 		sendPasswordChangeEmailUseCase.sendEmail( 			SendPwdChangeEmailCommandDto.builder().email(email).build()); 		return ResponseEntity.ok().build(); 	}  	@PostMapping(path = &quot;/{memberId}/points&quot;) 	public ResponseEntity&lt;ApiResponse&lt;ChargePointResponseDto&gt;&gt; chargePoint(@PathVariable String memberId, 		@Valid @RequestBody ChargePointRequestDto request) { 		var email = securityContextHelper.getEmailInToken(); 		var totalPoint = chargeMemberPointUseCase.chargePoint(request.convertToCommandDto(memberId, email)) 			.getTotalPoint(); 		var result = ChargePointResponseDto.builder().totalPoint(totalPoint).build(); 		return ResponseEntity.status(HttpStatus.OK).body(ApiResponse.wrap(result)); 	} }   재사용성과 의존성  해당 방식을 논의하던 중, 여러 유즈케이스에서 공통적으로 의존하는 로직이나 모듈에 대한 지적이 있었습니다. 공통적인 로직을 처리할 때는 ***Service라는 네이밍으로 적절한 추상화와 객체지향적 센스를 발휘하여 사용하기로 정하였습니다.  예시를 살펴보면 다음과 같습니다.  구매자의 “구매목록”을 담당하는 Purchase 도메인 내부의 생성 및 삭제 유즈 케이스입니다.  @Service public class CreatePurchaseUseCase {  	@Transactional 	public CreatePurchaseResultDto createPurchase(CreatePurchaseCommandDto command) {          //PurchaseService 		purchaseService.validateTicketingSalePeriod(ticketingId, command.getCommandCreatedAt());  		var newPurchase = purchaseRepository.save(Purchase.builder().member(member).build()); 		var tickets = ticketRepository.findByTicketingIdAndPurchaseIsNullOrderById( 			ticketingId, Limit.of(count));  		if (tickets.size() &lt; count) { 			throw new NotEnoughTicketException(); 		}  		tickets.forEach(ticket -&gt; { 			ticket.setPurchase(newPurchase); 		});  		return CreatePurchaseResultDto.builder() 			.purchaseId(newPurchase.getId()) 			.createdAt(newPurchase.getCreatedAt()) 			.build(); 	} }   @Service public class DeletePurchaseTicketsUseCase {  	@Transactional 	public void deletePurchaseTickets(DeletePurchaseTicketsCommandDto command) { 		var purchase = purchaseRepository.findById(command.getPurchaseId()).orElseThrow( 			PurchaseNotFoundException::new); 		var ticketsUnderPurchase = purchaseService.findTicketsUnderPurchase(purchase.getId()); 		var ticketsToRefund = ticketRepository.findAllById(command.getTicketIds()); 		var ticketing = ticketsUnderPurchase.getFirst().getTicketing();          //PurchaseService 		purchaseService.validatePurchaseOwnership(purchase.getId(), command.getMemberEmail()); 		purchaseService.validateTicketingSalePeriod(ticketing.getId(), command.getCommandCreatedAt());  		var ticketIdUnderPurchase = ticketsUnderPurchase.stream().map(Ticket::getId).toList(); 		AtomicInteger numOfDeletedTicket = new AtomicInteger(); 		ticketsToRefund.forEach(ticket -&gt; { 			if (ticketIdUnderPurchase.contains(ticket.getId())) { 				ticket.setPurchase(null); 				numOfDeletedTicket.getAndIncrement(); 			} 		}); 		if (numOfDeletedTicket.get() == ticketsUnderPurchase.size()) { 			purchaseRepository.delete(purchase); 		} 	} }    두가지 유즈케이스 모두 “구매”에 대한 Validation을 하는 공통 로직에 의존하고 있기 때문에 해당 로직은 PurchaseService에 위임하였습니다.  다이어그램으로 살펴보면 다음과 같습니다.    이를 통해 공통 로직과 의존도를 분리할 수 있었습니다.  후기  개인적으로 더이상 거대한 Service 객체를 보지 않아도 되는 면에서 가독성만큼은 훨씬 낫다고 생각합니다. 하나의 유즈케이스에 대해서만 집중해도 되니 유틸리티 메소드에 대한 의존성 관리도 쾌적해졌다고 느꼈습니다. 이전에 사용하던 계층 구조와 선택하라고 한다면 분명 현재를 고를 것입니다. 다만 우려되거나 아쉬운 부분 또한 존재합니다.  특히 우려되는 점은 서비스에 대한 오염입니다. 적절한 책임의 분리를 하지 않고 모든 유틸리티 메소드들을 밀어넣는 용도로 XXXService를 사용한다면 결국 재사용성이 떨어지는 거대객체가 될 확률이 높습니다.  이 글을 작성하면서 보니, 위 언급된 이미지에서의 PurchaseService 또한 Validation과 Find의 유틸리티 책임이 혼합되어있습니다. PurchaseValidationService와 PurchaseFindService로 쪼개는게 더 적절할 수도 있습니다.  아쉬운 부분은 Hexagonal 과 Clean Architecture, Domain Driven Design등에 대해서 조금 더 깊은 이해를 했거나 경험이 있었다면 더 좋은 아키텍처가 있을 수도 있다는 것이었습니다. 해당 부분은 사이드 프로젝트를 마무리한다면 깊게 한번 다시 탐구해보도록 하겠습니다.  감사합니다.">







  <meta property="article:published_time" content="2024-03-25T12:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/tiketeer/architecture/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Claycat",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Claycat Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->



<link
  rel="apple-touch-icon"
  sizes="180x180"
  href="/assets/images/favicons/apple-touch-icon.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="32x32"
  href="/assets/images/favicons/favicon-32x32.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="16x16"
  href="/assets/images/favicons/favicon-16x16.png"
/>

<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico" />
<meta name="apple-mobile-web-app-title" content="Claycat" />
<meta name="application-name" content="Claycat" />
<meta name="msapplication-TileColor" content="#da532c" />
<meta
  name="msapplication-config"
  content="/assets/images/favicons/browserconfig.xml"
/>
<meta name="theme-color" content="#ffffff" />

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Claycat
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
         

<div id="main" role="main">
  


  <article
    class="page h-entry"
    itemscope
    itemtype="https://schema.org/CreativeWork"
  >
    <meta
      itemprop="headline"
      content="스프링 코드 아키텍처"
    /> <meta
      itemprop="description"
      content="작성자 : Claycat개요여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다.프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요.결정 과정에 대해서 소개해 보려고 합니다.해당 프로젝트의 Github 여기 입니다.서론이전에 진행했던 프로젝트들은 전통적인 Layered Architecture로 이루어졌습니다.일반적으로 Controller, Service, Repository 세개의 레이어로 구성되어있습니다.Controller에서는 Service에 의존하고, Service에서는 Repository에 의존하는 방식입니다.조금 더 구체적인 예시를 들면 다음과 같습니다.해당 방식은 소규모의 프로젝트에서는 문제가 없었지만,다양한 유틸리티 메소드와 비즈니스 로직이 많아지고, API 엔드포인트들이 많아질수록 서비스단의 코드가 비대해졌습니다.서비스 코드가 몇백줄을 넘어가면서 유지보수성은 떨어지고 가독성 또한 낮아졌습니다.원인이 문제의 원인은 컨트롤러 - 서비스간의 1:1 관계 때문이라고 분석했습니다.위 Member 예제처럼 MemberController - MemberService로 연관되어있는 경우입니다.이 경우, MemberService는 MemberController의 모든 엔드포인트를 메소드로 구현해야 합니다.Member에 대한 모든 비즈니스 로직을 포함할 수 밖에 없고, 거대한 테스트 코드는 덤입니다.저희는 해당 도메인을 단 하나의 서비스 객체로 나타내는 구조는 거대한 객체를 유발하고,가독성과 유지보수성이 떨어지며,객체지향적으로도 너무 많은 책임을 갖는 좋지 않은 구조라고 판단하였습니다.대안해당 문제를 어떻게 해결할 수 있을지 회의를 하였고, 몇가지 제안들이 있었습니다.      CrudService          ✋ 비대한 서비스 코드를 줄일 수 있도록 CRUD관련 엔드포인트들만 별도로 처리하는 서비스 객체를 사용하자!            Hexagonal Architecture &amp; Clean Architecture          ✋ 익숙한 계층 아키텍처 대신 새로운 아키텍처를 도입해서 사용하자!            DDD의 아이디어 채용 - UseCase에 중점을 두자          ✋ 꼭 하나의 서비스가 여러개의 엔드포인트를 처리해야 할까?하나의 엔드포인트에 대한 하나의 서비스(유즈케이스)로서 대응하는건 어떨까?      논의      CrudService          🙆 비대한 서비스 코드의 부담을 일부분 덜어줄 수 있다는 것은 동의.                  🙅 하지만 결국 본질적인 문제를 해결하는것은 아니다.          🙅 CRUD이외의 엔드포인트가 다수 추가된다면 결국 비대해지는것은 마찬가지                          Hexagonal &amp; Clean Architecture          기존 계층구조로 구성된 코드를 모두 뒤엎어야 함                  🙅 참고할 수 있는 정석적인 자료가 부재하며, 참고자료마다 구현방식이 모두 다름                    🙆 Ports &amp; Adapter를 통해 외부 입력과 출력에 대해서 독립성을 확보할 수 있다                  🙅 in/out에 대한 port 및 adapter를 모두 작성해야 하는 불편함이 존재          🙅 사이드 프로젝트의 규모상 웹 요청방식은 HTTP이외가 추가되지 않을 것이며,마찬가지로 영속성 툴 또한 메인 DB (MySQL)에서 추가되지 않을 것인데, 오버엔지니어링이 아닐까                          UseCase 중심          🙆 익숙한 편이며, 서비스를 잘게 쪼갤 수 있다.      🙅 결국 모든 엔드포인트에 대해서 대응하는 유즈케이스 객체가 만들어질텐데, 너무 많아지지 않을까?                  🙆 어차피 작업중인 유즈케이스만 보게 될 것          🙆 동시에 여러 유즈케이스를 보는 상황이 온다면 의존성 문제가 생긴게 아닐까                    결론논의 결과, 저희는 UseCase를 중심으로 한, 세분화된 서비스 객체의 계층구조로 결정하였습니다.결론은 다음과 같습니다.      컨트롤러는 기존과 동일한 역할을 수행하고, 도메인별로 분리합니다.          API 엔드포인트 상                  /members/** -&gt; MemberController          /ticketings/** -&gt; TicketingController                          기존 서비스를 메소드별로 UseCase로 나누어 별도의 객체로 분리합니다.          MemberService 하위의                  memberService.login -&gt; LoginUseCase          memberService.register -&gt; RegisterUseCase          memberService.logout -&gt; LogoutUseCase                    코드를 살펴보면 다음과 같습니다.//편의상 주입 생략@RestController@RequestMapping(&quot;/members&quot;)public class MemberController {	@PostMapping(&quot;/register&quot;)	public ApiResponse&lt;MemberRegisterResponseDto&gt; registerMember(		final @Valid @RequestBody MemberRegisterRequestDto registerMemberDto) {		return ApiResponse.wrap(			MemberRegisterResponseDto.toDto(memberRegisterUseCase.register(MemberRegisterCommandDto.builder()				.email(registerMemberDto.getEmail())				.isSeller(registerMemberDto.getIsSeller())				.build()			))		);	}	@PostMapping(path = &quot;/password-reset/mail&quot;)	public ResponseEntity sendPasswordChangeEmail() {		var email = securityContextHelper.getEmailInToken();		sendPasswordChangeEmailUseCase.sendEmail(			SendPwdChangeEmailCommandDto.builder().email(email).build());		return ResponseEntity.ok().build();	}	@PostMapping(path = &quot;/{memberId}/points&quot;)	public ResponseEntity&lt;ApiResponse&lt;ChargePointResponseDto&gt;&gt; chargePoint(@PathVariable String memberId,		@Valid @RequestBody ChargePointRequestDto request) {		var email = securityContextHelper.getEmailInToken();		var totalPoint = chargeMemberPointUseCase.chargePoint(request.convertToCommandDto(memberId, email))			.getTotalPoint();		var result = ChargePointResponseDto.builder().totalPoint(totalPoint).build();		return ResponseEntity.status(HttpStatus.OK).body(ApiResponse.wrap(result));	}}재사용성과 의존성해당 방식을 논의하던 중, 여러 유즈케이스에서 공통적으로 의존하는 로직이나 모듈에 대한 지적이 있었습니다.공통적인 로직을 처리할 때는 ***Service라는 네이밍으로 적절한 추상화와 객체지향적 센스를 발휘하여 사용하기로 정하였습니다.예시를 살펴보면 다음과 같습니다.구매자의 “구매목록”을 담당하는 Purchase 도메인 내부의 생성 및 삭제 유즈 케이스입니다.@Servicepublic class CreatePurchaseUseCase {	@Transactional	public CreatePurchaseResultDto createPurchase(CreatePurchaseCommandDto command) {        //PurchaseService		purchaseService.validateTicketingSalePeriod(ticketingId, command.getCommandCreatedAt());		var newPurchase = purchaseRepository.save(Purchase.builder().member(member).build());		var tickets = ticketRepository.findByTicketingIdAndPurchaseIsNullOrderById(			ticketingId, Limit.of(count));		if (tickets.size() &lt; count) {			throw new NotEnoughTicketException();		}		tickets.forEach(ticket -&gt; {			ticket.setPurchase(newPurchase);		});		return CreatePurchaseResultDto.builder()			.purchaseId(newPurchase.getId())			.createdAt(newPurchase.getCreatedAt())			.build();	}}@Servicepublic class DeletePurchaseTicketsUseCase {	@Transactional	public void deletePurchaseTickets(DeletePurchaseTicketsCommandDto command) {		var purchase = purchaseRepository.findById(command.getPurchaseId()).orElseThrow(			PurchaseNotFoundException::new);		var ticketsUnderPurchase = purchaseService.findTicketsUnderPurchase(purchase.getId());		var ticketsToRefund = ticketRepository.findAllById(command.getTicketIds());		var ticketing = ticketsUnderPurchase.getFirst().getTicketing();        //PurchaseService		purchaseService.validatePurchaseOwnership(purchase.getId(), command.getMemberEmail());		purchaseService.validateTicketingSalePeriod(ticketing.getId(), command.getCommandCreatedAt());		var ticketIdUnderPurchase = ticketsUnderPurchase.stream().map(Ticket::getId).toList();		AtomicInteger numOfDeletedTicket = new AtomicInteger();		ticketsToRefund.forEach(ticket -&gt; {			if (ticketIdUnderPurchase.contains(ticket.getId())) {				ticket.setPurchase(null);				numOfDeletedTicket.getAndIncrement();			}		});		if (numOfDeletedTicket.get() == ticketsUnderPurchase.size()) {			purchaseRepository.delete(purchase);		}	}}두가지 유즈케이스 모두 “구매”에 대한 Validation을 하는 공통 로직에 의존하고 있기 때문에해당 로직은 PurchaseService에 위임하였습니다.다이어그램으로 살펴보면 다음과 같습니다.이를 통해 공통 로직과 의존도를 분리할 수 있었습니다.후기개인적으로 더이상 거대한 Service 객체를 보지 않아도 되는 면에서 가독성만큼은 훨씬 낫다고 생각합니다.하나의 유즈케이스에 대해서만 집중해도 되니 유틸리티 메소드에 대한 의존성 관리도 쾌적해졌다고 느꼈습니다.이전에 사용하던 계층 구조와 선택하라고 한다면 분명 현재를 고를 것입니다.다만 우려되거나 아쉬운 부분 또한 존재합니다.특히 우려되는 점은 서비스에 대한 오염입니다.적절한 책임의 분리를 하지 않고 모든 유틸리티 메소드들을 밀어넣는 용도로 XXXService를 사용한다면결국 재사용성이 떨어지는 거대객체가 될 확률이 높습니다.이 글을 작성하면서 보니, 위 언급된 이미지에서의 PurchaseService 또한 Validation과 Find의 유틸리티 책임이 혼합되어있습니다.PurchaseValidationService와 PurchaseFindService로 쪼개는게 더 적절할 수도 있습니다.아쉬운 부분은 Hexagonal 과 Clean Architecture, Domain Driven Design등에 대해서 조금 더 깊은 이해를 했거나경험이 있었다면 더 좋은 아키텍처가 있을 수도 있다는 것이었습니다.해당 부분은 사이드 프로젝트를 마무리한다면 깊게 한번 다시 탐구해보도록 하겠습니다.감사합니다."
    /> <meta
      itemprop="datePublished"
      content="2024-03-25T12:00:00+09:00"
    /> 

    <div class="page__inner-wrap">
      
      <header>
        
        <h1 id="page-title" class="page__title" itemprop="headline">
          <p>스프링 코드 아키텍처</p>

        </h1>
         
      </header>
      

      <section class="page__content e-content" itemprop="text">
         <p>작성자 : <a href="https://github.com/claycat">Claycat</a></p>

<h2 id="개요">개요</h2>

<h3 id="여러분들의-백엔드-프로젝트-아키텍처는-어떤가요">여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?</h3>

<p>이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다.<br />
프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요.<br />
결정 과정에 대해서 소개해 보려고 합니다.</p>

<p>해당 프로젝트의 Github <a href="https://github.com/Tiketeer/Tiketeer-BE">여기</a> 입니다.</p>

<h2 id="서론">서론</h2>

<p>이전에 진행했던 프로젝트들은 전통적인 Layered Architecture로 이루어졌습니다.</p>

<p><img src="/images/../../assets/images/2024-04-02-21-08-08.png" alt="" /></p>

<p>일반적으로 Controller, Service, Repository 세개의 레이어로 구성되어있습니다.
Controller에서는 Service에 의존하고, Service에서는 Repository에 의존하는 방식입니다.</p>

<p>조금 더 구체적인 예시를 들면 다음과 같습니다.</p>

<p><img src="/images/../../assets/images/2024-04-02-21-08-54.png" alt="" /></p>

<p>해당 방식은 소규모의 프로젝트에서는 문제가 없었지만,<br />
다양한 유틸리티 메소드와 비즈니스 로직이 많아지고, API 엔드포인트들이 많아질수록 서비스단의 코드가 비대해졌습니다.<br />
서비스 코드가 몇백줄을 넘어가면서 유지보수성은 떨어지고 가독성 또한 낮아졌습니다.</p>

<h2 id="원인">원인</h2>

<p>이 문제의 원인은 컨트롤러 - 서비스간의 1:1 관계 때문이라고 분석했습니다.
위 Member 예제처럼 MemberController - MemberService로 연관되어있는 경우입니다.<br />
이 경우, MemberService는 MemberController의 모든 엔드포인트를 메소드로 구현해야 합니다.<br />
Member에 대한 모든 비즈니스 로직을 포함할 수 밖에 없고, 거대한 테스트 코드는 덤입니다.</p>

<p>저희는 해당 도메인을 단 하나의 서비스 객체로 나타내는 구조는 거대한 객체를 유발하고,<br />
가독성과 유지보수성이 떨어지며,<br />
객체지향적으로도 너무 많은 책임을 갖는 좋지 않은 구조라고 판단하였습니다.</p>

<h2 id="대안">대안</h2>

<p>해당 문제를 어떻게 해결할 수 있을지 회의를 하였고, 몇가지 제안들이 있었습니다.</p>

<ol>
  <li>
    <p>CrudService</p>

    <ul>
      <li>✋ 비대한 서비스 코드를 줄일 수 있도록 CRUD관련 엔드포인트들만 별도로 처리하는 서비스 객체를 사용하자!</li>
    </ul>
  </li>
  <li>
    <p>Hexagonal Architecture &amp; Clean Architecture</p>

    <ul>
      <li>✋ 익숙한 계층 아키텍처 대신 새로운 아키텍처를 도입해서 사용하자!</li>
    </ul>
  </li>
  <li>
    <p>DDD의 아이디어 채용 - UseCase에 중점을 두자</p>

    <ul>
      <li>✋ 꼭 하나의 서비스가 여러개의 엔드포인트를 처리해야 할까?<br />
하나의 엔드포인트에 대한 하나의 서비스(유즈케이스)로서 대응하는건 어떨까?</li>
    </ul>
  </li>
</ol>

<h2 id="논의">논의</h2>

<ol>
  <li>
    <p>CrudService</p>

    <ul>
      <li>🙆 비대한 서비스 코드의 부담을 일부분 덜어줄 수 있다는 것은 동의.
        <ul>
          <li>🙅 하지만 결국 본질적인 문제를 해결하는것은 아니다.</li>
          <li>🙅 CRUD이외의 엔드포인트가 다수 추가된다면 결국 비대해지는것은 마찬가지</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Hexagonal &amp; Clean Architecture</p>

    <ul>
      <li>기존 계층구조로 구성된 코드를 모두 뒤엎어야 함
        <ul>
          <li>🙅 참고할 수 있는 정석적인 자료가 부재하며, 참고자료마다 구현방식이 모두 다름</li>
        </ul>
      </li>
      <li>🙆 Ports &amp; Adapter를 통해 외부 입력과 출력에 대해서 독립성을 확보할 수 있다
        <ul>
          <li>🙅 in/out에 대한 port 및 adapter를 모두 작성해야 하는 불편함이 존재</li>
          <li>🙅 사이드 프로젝트의 규모상 웹 요청방식은 HTTP이외가 추가되지 않을 것이며,<br />
마찬가지로 영속성 툴 또한 메인 DB (MySQL)에서 추가되지 않을 것인데, 오버엔지니어링이 아닐까</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>UseCase 중심</p>
    <ul>
      <li>🙆 익숙한 편이며, 서비스를 잘게 쪼갤 수 있다.</li>
      <li>🙅 결국 모든 엔드포인트에 대해서 대응하는 유즈케이스 객체가 만들어질텐데, 너무 많아지지 않을까?
        <ul>
          <li>🙆 어차피 작업중인 유즈케이스만 보게 될 것</li>
          <li>🙆 동시에 여러 유즈케이스를 보는 상황이 온다면 의존성 문제가 생긴게 아닐까</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h2 id="결론">결론</h2>

<p>논의 결과, 저희는 UseCase를 중심으로 한, 세분화된 서비스 객체의 계층구조로 결정하였습니다.</p>

<p>결론은 다음과 같습니다.</p>

<ul>
  <li>
    <p>컨트롤러는 기존과 동일한 역할을 수행하고, 도메인별로 분리합니다.</p>

    <ul>
      <li>API 엔드포인트 상
        <ul>
          <li>/members/** -&gt; MemberController</li>
          <li>/ticketings/** -&gt; TicketingController</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>기존 서비스를 메소드별로 UseCase로 나누어 별도의 객체로 분리합니다.</p>
    <ul>
      <li>MemberService 하위의
        <ul>
          <li>memberService.login -&gt; LoginUseCase</li>
          <li>memberService.register -&gt; RegisterUseCase</li>
          <li>memberService.logout -&gt; LogoutUseCase</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>코드를 살펴보면 다음과 같습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//편의상 주입 생략</span>

<span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/members"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberController</span> <span class="o">{</span>

	<span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"/register"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nc">ApiResponse</span><span class="o">&lt;</span><span class="nc">MemberRegisterResponseDto</span><span class="o">&gt;</span> <span class="nf">registerMember</span><span class="o">(</span>
		<span class="kd">final</span> <span class="nd">@Valid</span> <span class="nd">@RequestBody</span> <span class="nc">MemberRegisterRequestDto</span> <span class="n">registerMemberDto</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="nc">ApiResponse</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span>
			<span class="nc">MemberRegisterResponseDto</span><span class="o">.</span><span class="na">toDto</span><span class="o">(</span><span class="n">memberRegisterUseCase</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="nc">MemberRegisterCommandDto</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
				<span class="o">.</span><span class="na">email</span><span class="o">(</span><span class="n">registerMemberDto</span><span class="o">.</span><span class="na">getEmail</span><span class="o">())</span>
				<span class="o">.</span><span class="na">isSeller</span><span class="o">(</span><span class="n">registerMemberDto</span><span class="o">.</span><span class="na">getIsSeller</span><span class="o">())</span>
				<span class="o">.</span><span class="na">build</span><span class="o">()</span>
			<span class="o">))</span>
		<span class="o">);</span>
	<span class="o">}</span>

	<span class="nd">@PostMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/password-reset/mail"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">sendPasswordChangeEmail</span><span class="o">()</span> <span class="o">{</span>
		<span class="kt">var</span> <span class="n">email</span> <span class="o">=</span> <span class="n">securityContextHelper</span><span class="o">.</span><span class="na">getEmailInToken</span><span class="o">();</span>
		<span class="n">sendPasswordChangeEmailUseCase</span><span class="o">.</span><span class="na">sendEmail</span><span class="o">(</span>
			<span class="nc">SendPwdChangeEmailCommandDto</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">email</span><span class="o">(</span><span class="n">email</span><span class="o">).</span><span class="na">build</span><span class="o">());</span>
		<span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="nd">@PostMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/{memberId}/points"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ApiResponse</span><span class="o">&lt;</span><span class="nc">ChargePointResponseDto</span><span class="o">&gt;&gt;</span> <span class="nf">chargePoint</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">String</span> <span class="n">memberId</span><span class="o">,</span>
		<span class="nd">@Valid</span> <span class="nd">@RequestBody</span> <span class="nc">ChargePointRequestDto</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">var</span> <span class="n">email</span> <span class="o">=</span> <span class="n">securityContextHelper</span><span class="o">.</span><span class="na">getEmailInToken</span><span class="o">();</span>
		<span class="kt">var</span> <span class="n">totalPoint</span> <span class="o">=</span> <span class="n">chargeMemberPointUseCase</span><span class="o">.</span><span class="na">chargePoint</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">convertToCommandDto</span><span class="o">(</span><span class="n">memberId</span><span class="o">,</span> <span class="n">email</span><span class="o">))</span>
			<span class="o">.</span><span class="na">getTotalPoint</span><span class="o">();</span>
		<span class="kt">var</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">ChargePointResponseDto</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">totalPoint</span><span class="o">(</span><span class="n">totalPoint</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
		<span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">status</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">).</span><span class="na">body</span><span class="o">(</span><span class="nc">ApiResponse</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="재사용성과-의존성">재사용성과 의존성</h2>

<p>해당 방식을 논의하던 중, 여러 유즈케이스에서 공통적으로 의존하는 로직이나 모듈에 대한 지적이 있었습니다.<br />
공통적인 로직을 처리할 때는 ***Service라는 네이밍으로 적절한 추상화와 객체지향적 센스를 발휘하여 사용하기로 정하였습니다.</p>

<p>예시를 살펴보면 다음과 같습니다.</p>

<p>구매자의 “구매목록”을 담당하는 Purchase 도메인 내부의 생성 및 삭제 유즈 케이스입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CreatePurchaseUseCase</span> <span class="o">{</span>

	<span class="nd">@Transactional</span>
	<span class="kd">public</span> <span class="nc">CreatePurchaseResultDto</span> <span class="nf">createPurchase</span><span class="o">(</span><span class="nc">CreatePurchaseCommandDto</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//PurchaseService</span>
		<span class="n">purchaseService</span><span class="o">.</span><span class="na">validateTicketingSalePeriod</span><span class="o">(</span><span class="n">ticketingId</span><span class="o">,</span> <span class="n">command</span><span class="o">.</span><span class="na">getCommandCreatedAt</span><span class="o">());</span>

		<span class="kt">var</span> <span class="n">newPurchase</span> <span class="o">=</span> <span class="n">purchaseRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="nc">Purchase</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">member</span><span class="o">(</span><span class="n">member</span><span class="o">).</span><span class="na">build</span><span class="o">());</span>
		<span class="kt">var</span> <span class="n">tickets</span> <span class="o">=</span> <span class="n">ticketRepository</span><span class="o">.</span><span class="na">findByTicketingIdAndPurchaseIsNullOrderById</span><span class="o">(</span>
			<span class="n">ticketingId</span><span class="o">,</span> <span class="nc">Limit</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">count</span><span class="o">));</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">tickets</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">NotEnoughTicketException</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="n">tickets</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">ticket</span> <span class="o">-&gt;</span> <span class="o">{</span>
			<span class="n">ticket</span><span class="o">.</span><span class="na">setPurchase</span><span class="o">(</span><span class="n">newPurchase</span><span class="o">);</span>
		<span class="o">});</span>

		<span class="k">return</span> <span class="nc">CreatePurchaseResultDto</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
			<span class="o">.</span><span class="na">purchaseId</span><span class="o">(</span><span class="n">newPurchase</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span>
			<span class="o">.</span><span class="na">createdAt</span><span class="o">(</span><span class="n">newPurchase</span><span class="o">.</span><span class="na">getCreatedAt</span><span class="o">())</span>
			<span class="o">.</span><span class="na">build</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>


<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeletePurchaseTicketsUseCase</span> <span class="o">{</span>

	<span class="nd">@Transactional</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">deletePurchaseTickets</span><span class="o">(</span><span class="nc">DeletePurchaseTicketsCommandDto</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">var</span> <span class="n">purchase</span> <span class="o">=</span> <span class="n">purchaseRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">command</span><span class="o">.</span><span class="na">getPurchaseId</span><span class="o">()).</span><span class="na">orElseThrow</span><span class="o">(</span>
			<span class="nl">PurchaseNotFoundException:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
		<span class="kt">var</span> <span class="n">ticketsUnderPurchase</span> <span class="o">=</span> <span class="n">purchaseService</span><span class="o">.</span><span class="na">findTicketsUnderPurchase</span><span class="o">(</span><span class="n">purchase</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
		<span class="kt">var</span> <span class="n">ticketsToRefund</span> <span class="o">=</span> <span class="n">ticketRepository</span><span class="o">.</span><span class="na">findAllById</span><span class="o">(</span><span class="n">command</span><span class="o">.</span><span class="na">getTicketIds</span><span class="o">());</span>
		<span class="kt">var</span> <span class="n">ticketing</span> <span class="o">=</span> <span class="n">ticketsUnderPurchase</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">getTicketing</span><span class="o">();</span>

        <span class="c1">//PurchaseService</span>
		<span class="n">purchaseService</span><span class="o">.</span><span class="na">validatePurchaseOwnership</span><span class="o">(</span><span class="n">purchase</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">command</span><span class="o">.</span><span class="na">getMemberEmail</span><span class="o">());</span>
		<span class="n">purchaseService</span><span class="o">.</span><span class="na">validateTicketingSalePeriod</span><span class="o">(</span><span class="n">ticketing</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">command</span><span class="o">.</span><span class="na">getCommandCreatedAt</span><span class="o">());</span>

		<span class="kt">var</span> <span class="n">ticketIdUnderPurchase</span> <span class="o">=</span> <span class="n">ticketsUnderPurchase</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">Ticket:</span><span class="o">:</span><span class="n">getId</span><span class="o">).</span><span class="na">toList</span><span class="o">();</span>
		<span class="nc">AtomicInteger</span> <span class="n">numOfDeletedTicket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">();</span>
		<span class="n">ticketsToRefund</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">ticket</span> <span class="o">-&gt;</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">ticketIdUnderPurchase</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">ticket</span><span class="o">.</span><span class="na">getId</span><span class="o">()))</span> <span class="o">{</span>
				<span class="n">ticket</span><span class="o">.</span><span class="na">setPurchase</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
				<span class="n">numOfDeletedTicket</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span>
			<span class="o">}</span>
		<span class="o">});</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">numOfDeletedTicket</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">==</span> <span class="n">ticketsUnderPurchase</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">purchaseRepository</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">purchase</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>두가지 유즈케이스 모두 “구매”에 대한 Validation을 하는 공통 로직에 의존하고 있기 때문에<br />
해당 로직은 PurchaseService에 위임하였습니다.</p>

<p>다이어그램으로 살펴보면 다음과 같습니다.</p>

<p><img src="/images/../../assets/images/2024-04-02-21-09-47.png" alt="" /></p>

<p>이를 통해 공통 로직과 의존도를 분리할 수 있었습니다.</p>

<h2 id="후기">후기</h2>

<p>개인적으로 더이상 거대한 Service 객체를 보지 않아도 되는 면에서 가독성만큼은 훨씬 낫다고 생각합니다.
하나의 유즈케이스에 대해서만 집중해도 되니 유틸리티 메소드에 대한 의존성 관리도 쾌적해졌다고 느꼈습니다.<br />
이전에 사용하던 계층 구조와 선택하라고 한다면 분명 현재를 고를 것입니다.<br />
다만 우려되거나 아쉬운 부분 또한 존재합니다.</p>

<p>특히 우려되는 점은 서비스에 대한 오염입니다.<br />
적절한 책임의 분리를 하지 않고 모든 유틸리티 메소드들을 밀어넣는 용도로 XXXService를 사용한다면<br />
결국 재사용성이 떨어지는 거대객체가 될 확률이 높습니다.</p>

<p>이 글을 작성하면서 보니, 위 언급된 이미지에서의 PurchaseService 또한 Validation과 Find의 유틸리티 책임이 혼합되어있습니다.<br />
PurchaseValidationService와 PurchaseFindService로 쪼개는게 더 적절할 수도 있습니다.</p>

<p>아쉬운 부분은 Hexagonal 과 Clean Architecture, Domain Driven Design등에 대해서 조금 더 깊은 이해를 했거나<br />
경험이 있었다면 더 좋은 아키텍처가 있을 수도 있다는 것이었습니다.<br />
해당 부분은 사이드 프로젝트를 마무리한다면 깊게 한번 다시 탐구해보도록 하겠습니다.</p>

<p>감사합니다.</p>
 
      </section>

      <footer class="page__meta">
         
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 태그: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#spring" class="page__taxonomy-item p-category" rel="tag">spring</a><span class="sep">, </span>
    
      <a href="/tags/#tiketeer" class="page__taxonomy-item p-category" rel="tag">tiketeer</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 카테고리: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#tiketeer" class="page__taxonomy-item p-category" rel="tag">Tiketeer</a>
    
    </span>
  </p>

 

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 업데이트:</strong> <time class="dt-published" datetime="2024-03-25T12:00:00+09:00">March 25, 2024</time></p>

      </footer>
      
  <nav class="pagination">
    
      <a href="/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/isp1/" class="pagination--pager" title="인터페이스 분리 원칙에 대해
">이전</a>
    
    
      <a href="/tiketeer/concurrency/" class="pagination--pager" title="티케팅 시스템 구현에서의 동시성 문제 : 원인
">다음</a>
    
  </nav>

    </div>

    
  </article>

   
  <div class="page__related">
    <h2 class="page__related-title">
      참고
    </h2>
    <div class="grid__wrapper">
       



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/concurrency/" rel="permalink">티케팅 시스템 구현에서의 동시성 문제 : 원인
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> April 02 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">개요
</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/isp1/" rel="permalink">인터페이스 분리 원칙에 대해
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">다 알고 있는 사실

  어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다
자신이 사용하는 메서드에만 의존해야 한다


매번 나오는 설명입니다.
보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.

interface Person {
	public void ...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/jpa/persistance2/" rel="permalink">영속성 까보기 (feat. 10분 테코톡)
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">JPA와 영속성

JPA 영속성 관련 실험 중 이상한 케이스를 발견했습니다.
우아한형제들 테코톡의 문제상황 1에서도 비슷한 예제가 있습니다.
영상에서는 정확히 이유를 설명하지는 않고 영속성 설명으로 넘어가버려서
정확한 이유를 정리해보려고 합니다.

@Getter
@Entity
@A...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/interview/ms_java1/" rel="permalink">CS 면접대비 - 프로그래밍 언어(자바)
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 24 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">❓Call by Value 와 Call by reference의 차이가 무엇인가요?
</p>
  </article>
</div>
 
    </div>
  </div>
   
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력하세요..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>팔로우:</strong></li>
    

    
      
        
          <li><a href="https://github.com/claycat" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Claycat. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', 'claycat');
    script.setAttribute('data-repo-id', 'R_kgDOLLYTXw');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOLLYTX84Ccyz5');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>
  





  </body>
</html>
