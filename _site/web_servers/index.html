<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ko" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>웹 서버와 포트, 소켓, 그리고 스레드 : Claycat</title>
<meta name="description" content="웹 서버와 포트, 소켓, 그리고 스레드    지금까지 웹서버를 설정할 때 아무 생각 없이 포트 설정을 해 왔다. Nestjs 라면 아래와 같이,  // main.ts async function bootstrap() {   const app = await NestFactory.create(AppModule);   await app.listen(3000); //  port } bootstrap();   SpringBoot라면  //application.properties server.port=8080   이런 식으로 말이다.  이번에 네트워크 관련 스터디를 하면서 포트와 소켓, 그리고 스레드에 대해서 몇가지 의문들이 들었는데, 이번 포스팅에서 하나씩 해결해보려고 한다.    먼저 한가지 질문으로 시작해보려고 한다.     소켓은 하나의 포트와 매칭되는가?   그렇다. 포트와 IP 주소를 조합하여 하나의 소켓을 구성한다.     하나의 요청은 하나의 소켓을 갖는다?   당연하게도 그럴것 같다. 서로 다른 요청들을 구분하고 TCP 연결을 맻으려면 서로 다른 포트(소켓)을 가져야 한다.  웹서버를 구축할 때 설정한 포트는 하나인데?  여러개의 요청을 동시에 처리하려면 당연히 여러개의 포트를 사용할것이다. 우리가 웹서버 애플리케이션에 배정한 포트는 하나인데, 어떻게 여러개의 동시 요청들을 처리하는걸까?  Listening Port  사실 우리가 서버를 구축할 때 주는 포트번호는 Listening Port라는 특수한 포트이다. 이 포트는 클라이언트들로부터 들어오는 연결 요청을 기다린다. 즉, 우리가 설정한 포트는 어디까지나 중재자 역할을 할 뿐, 직접 요청을 처리하는것이 아니다.    Ports and Sockets  웹서버는 listening port를 이용해서 요청을 기다린다. 요청이 들어올 경우, 받은 요청에 ephemeral port(~1024의 예약 포트를 제외한 나머지) 라고 하는 임시 커넥션 포트를 사용하여 동적으로 소켓을 만들어준다.  생성된 소켓은 톰캣과 같은 멀티스레드 웹서버 환경에서는 보유하고 있는 스레드 풀에서 스레드를 배정받아 요청을 처리하고, Nodejs 와 같은 싱글스레드 환경이라면 이벤트 루프가 request handler를 호출하여 해당 요청을 처리해준다.    Concurrency  포트개수가 많긴 하지만 결국 6만개밖에 없는게 아닌가? 만약 그 이상의 연결이 들어온다면 웹서버는 요청을 받을 수 없는걸까?  그렇지 않다. 웹서버는 5개의 원소를 가진 tuple을 통해 connection을 구분한다. Source IP, Source Port, Destination IP, Destination Port, Protocol 이중 하나라도 다르다면 별도의 connection으로 취급하는 것이다.  즉, 두 서버간 총 64K의 Connection이 가능하다는 의미이다.  따라서 포트 하나만 있더라도 서버의 리소스만 충분하다면 Source IP 주소가 모두 다르기 때문에 문제가 없다.    쉬어가기 - Processes and Threads  옛날 웹서버들은 사실 하나의 연결당 하나의 프로세스를 배정하는 process-per-connection 정책을 사용하였다. 다만 IPC와 프로세스 생성 / 해제의 오버헤드로 인해 프로세스가 아닌 스레드를 배정하는 thread-per-connection 정책을 사용하거나, nodejs와 같은 비동기 방식을 채택하였다.    HTTP/1.1 - Connection Overhead  연결 요청마다 매번 새로운 소켓을 생성하고 TCP 요청을 수립하는것은 당연히 비효율적일 것이다. 이를 해결하기 위해 HTTP/1.1 스펙에서는 Keep-alive라는 옵션이 추가되어, 연결을 재사용하는것이 가능하게 되었다.    Thread per connection vs Thread per request  다시 스레드로 돌아가보자. 연결 하나당 스레드 하나가 배정된다면, 연결 사이사이에 스레드가 놀지 않을까?  사실 현재 웹서버들은 하나의 “연결”에 대해서 스레드를 배정하지 않고, 하나의 “요청” 단위로 스레드를 배정한다(Thread per request)  요청 단위로 스레드를 배정한다면 생성비용과 해제비용은 어떻게 감당할까? 앞에서 잠깐 이야기했듯, 멀티스레드 웹서버들은 스레드풀을 사용하여 관리한다. 이게 가능한 이유는 http의 stateless한 특성 때문이라고 이해할 수 있다.  생각해보기 - KeepAlive &amp; Thread per request?  HTTP/1.1의 KeepAlive는 추가적인 요청에 대해서 연결을 재활용하기 위해 바로 스레드가 반납되지 않고 잠깐 살아있게 된다.  이게 Thread per request 모델과 공생이 가능할까?  스레드를 재활용하는것은 엄격하게 보면 Thread per connection이 아닐까?">



<meta property="og:type" content="article">
<meta property="og:locale" content="ko_KR">
<meta property="og:site_name" content="Claycat">
<meta property="og:title" content="웹 서버와 포트, 소켓, 그리고 스레드">
<meta property="og:url" content="http://localhost:4000/web_servers/">


  <meta property="og:description" content="웹 서버와 포트, 소켓, 그리고 스레드    지금까지 웹서버를 설정할 때 아무 생각 없이 포트 설정을 해 왔다. Nestjs 라면 아래와 같이,  // main.ts async function bootstrap() {   const app = await NestFactory.create(AppModule);   await app.listen(3000); //  port } bootstrap();   SpringBoot라면  //application.properties server.port=8080   이런 식으로 말이다.  이번에 네트워크 관련 스터디를 하면서 포트와 소켓, 그리고 스레드에 대해서 몇가지 의문들이 들었는데, 이번 포스팅에서 하나씩 해결해보려고 한다.    먼저 한가지 질문으로 시작해보려고 한다.     소켓은 하나의 포트와 매칭되는가?   그렇다. 포트와 IP 주소를 조합하여 하나의 소켓을 구성한다.     하나의 요청은 하나의 소켓을 갖는다?   당연하게도 그럴것 같다. 서로 다른 요청들을 구분하고 TCP 연결을 맻으려면 서로 다른 포트(소켓)을 가져야 한다.  웹서버를 구축할 때 설정한 포트는 하나인데?  여러개의 요청을 동시에 처리하려면 당연히 여러개의 포트를 사용할것이다. 우리가 웹서버 애플리케이션에 배정한 포트는 하나인데, 어떻게 여러개의 동시 요청들을 처리하는걸까?  Listening Port  사실 우리가 서버를 구축할 때 주는 포트번호는 Listening Port라는 특수한 포트이다. 이 포트는 클라이언트들로부터 들어오는 연결 요청을 기다린다. 즉, 우리가 설정한 포트는 어디까지나 중재자 역할을 할 뿐, 직접 요청을 처리하는것이 아니다.    Ports and Sockets  웹서버는 listening port를 이용해서 요청을 기다린다. 요청이 들어올 경우, 받은 요청에 ephemeral port(~1024의 예약 포트를 제외한 나머지) 라고 하는 임시 커넥션 포트를 사용하여 동적으로 소켓을 만들어준다.  생성된 소켓은 톰캣과 같은 멀티스레드 웹서버 환경에서는 보유하고 있는 스레드 풀에서 스레드를 배정받아 요청을 처리하고, Nodejs 와 같은 싱글스레드 환경이라면 이벤트 루프가 request handler를 호출하여 해당 요청을 처리해준다.    Concurrency  포트개수가 많긴 하지만 결국 6만개밖에 없는게 아닌가? 만약 그 이상의 연결이 들어온다면 웹서버는 요청을 받을 수 없는걸까?  그렇지 않다. 웹서버는 5개의 원소를 가진 tuple을 통해 connection을 구분한다. Source IP, Source Port, Destination IP, Destination Port, Protocol 이중 하나라도 다르다면 별도의 connection으로 취급하는 것이다.  즉, 두 서버간 총 64K의 Connection이 가능하다는 의미이다.  따라서 포트 하나만 있더라도 서버의 리소스만 충분하다면 Source IP 주소가 모두 다르기 때문에 문제가 없다.    쉬어가기 - Processes and Threads  옛날 웹서버들은 사실 하나의 연결당 하나의 프로세스를 배정하는 process-per-connection 정책을 사용하였다. 다만 IPC와 프로세스 생성 / 해제의 오버헤드로 인해 프로세스가 아닌 스레드를 배정하는 thread-per-connection 정책을 사용하거나, nodejs와 같은 비동기 방식을 채택하였다.    HTTP/1.1 - Connection Overhead  연결 요청마다 매번 새로운 소켓을 생성하고 TCP 요청을 수립하는것은 당연히 비효율적일 것이다. 이를 해결하기 위해 HTTP/1.1 스펙에서는 Keep-alive라는 옵션이 추가되어, 연결을 재사용하는것이 가능하게 되었다.    Thread per connection vs Thread per request  다시 스레드로 돌아가보자. 연결 하나당 스레드 하나가 배정된다면, 연결 사이사이에 스레드가 놀지 않을까?  사실 현재 웹서버들은 하나의 “연결”에 대해서 스레드를 배정하지 않고, 하나의 “요청” 단위로 스레드를 배정한다(Thread per request)  요청 단위로 스레드를 배정한다면 생성비용과 해제비용은 어떻게 감당할까? 앞에서 잠깐 이야기했듯, 멀티스레드 웹서버들은 스레드풀을 사용하여 관리한다. 이게 가능한 이유는 http의 stateless한 특성 때문이라고 이해할 수 있다.  생각해보기 - KeepAlive &amp; Thread per request?  HTTP/1.1의 KeepAlive는 추가적인 요청에 대해서 연결을 재활용하기 위해 바로 스레드가 반납되지 않고 잠깐 살아있게 된다.  이게 Thread per request 모델과 공생이 가능할까?  스레드를 재활용하는것은 엄격하게 보면 Thread per connection이 아닐까?">







  <meta property="article:published_time" content="2024-01-24T12:00:00+09:00">





  

  


<link rel="canonical" href="http://localhost:4000/web_servers/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Claycat",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Claycat Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->



<link
  rel="apple-touch-icon"
  sizes="180x180"
  href="/assets/images/favicons/apple-touch-icon.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="32x32"
  href="/assets/images/favicons/favicon-32x32.png"
/>
<link
  rel="icon"
  type="image/png"
  sizes="16x16"
  href="/assets/images/favicons/favicon-16x16.png"
/>

<link rel="shortcut icon" href="/assets/images/favicons/favicon.ico" />
<meta name="apple-mobile-web-app-title" content="Claycat" />
<meta name="application-name" content="Claycat" />
<meta name="msapplication-TileColor" content="#da532c" />
<meta
  name="msapplication-config"
  content="/assets/images/favicons/browserconfig.xml"
/>
<meta name="theme-color" content="#ffffff" />

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Claycat
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">토글 메뉴</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
         

<div id="main" role="main">
  


  <article
    class="page h-entry"
    itemscope
    itemtype="https://schema.org/CreativeWork"
  >
    <meta
      itemprop="headline"
      content="웹 서버와 포트, 소켓, 그리고 스레드"
    /> <meta
      itemprop="description"
      content="웹 서버와 포트, 소켓, 그리고 스레드지금까지 웹서버를 설정할 때 아무 생각 없이 포트 설정을 해 왔다.Nestjs 라면 아래와 같이,// main.tsasync function bootstrap() {  const app = await NestFactory.create(AppModule);  await app.listen(3000); //  port}bootstrap();SpringBoot라면//application.propertiesserver.port=8080이런 식으로 말이다.이번에 네트워크 관련 스터디를 하면서 포트와 소켓, 그리고 스레드에 대해서 몇가지 의문들이 들었는데, 이번 포스팅에서 하나씩 해결해보려고 한다.먼저 한가지 질문으로 시작해보려고 한다.  소켓은 하나의 포트와 매칭되는가?그렇다.포트와 IP 주소를 조합하여 하나의 소켓을 구성한다.  하나의 요청은 하나의 소켓을 갖는다?당연하게도 그럴것 같다. 서로 다른 요청들을 구분하고 TCP 연결을 맻으려면 서로 다른 포트(소켓)을 가져야 한다.웹서버를 구축할 때 설정한 포트는 하나인데?여러개의 요청을 동시에 처리하려면 당연히 여러개의 포트를 사용할것이다.우리가 웹서버 애플리케이션에 배정한 포트는 하나인데, 어떻게 여러개의 동시 요청들을 처리하는걸까?Listening Port사실 우리가 서버를 구축할 때 주는 포트번호는 Listening Port라는 특수한 포트이다.이 포트는 클라이언트들로부터 들어오는 연결 요청을 기다린다.즉, 우리가 설정한 포트는 어디까지나 중재자 역할을 할 뿐, 직접 요청을 처리하는것이 아니다.Ports and Sockets웹서버는 listening port를 이용해서 요청을 기다린다.요청이 들어올 경우, 받은 요청에 ephemeral port(~1024의 예약 포트를 제외한 나머지) 라고 하는 임시 커넥션 포트를 사용하여 동적으로 소켓을 만들어준다.생성된 소켓은 톰캣과 같은 멀티스레드 웹서버 환경에서는 보유하고 있는 스레드 풀에서 스레드를 배정받아 요청을 처리하고,Nodejs 와 같은 싱글스레드 환경이라면 이벤트 루프가 request handler를 호출하여 해당 요청을 처리해준다.Concurrency포트개수가 많긴 하지만 결국 6만개밖에 없는게 아닌가? 만약 그 이상의 연결이 들어온다면 웹서버는 요청을 받을 수 없는걸까?그렇지 않다.웹서버는 5개의 원소를 가진 tuple을 통해 connection을 구분한다.Source IP, Source Port, Destination IP, Destination Port, Protocol이중 하나라도 다르다면 별도의 connection으로 취급하는 것이다.즉, 두 서버간 총 64K의 Connection이 가능하다는 의미이다.따라서 포트 하나만 있더라도 서버의 리소스만 충분하다면 Source IP 주소가 모두 다르기 때문에 문제가 없다.쉬어가기 - Processes and Threads옛날 웹서버들은 사실 하나의 연결당 하나의 프로세스를 배정하는 process-per-connection 정책을 사용하였다.다만 IPC와 프로세스 생성 / 해제의 오버헤드로 인해 프로세스가 아닌 스레드를 배정하는thread-per-connection 정책을 사용하거나, nodejs와 같은 비동기 방식을 채택하였다.HTTP/1.1 - Connection Overhead연결 요청마다 매번 새로운 소켓을 생성하고 TCP 요청을 수립하는것은 당연히 비효율적일 것이다.이를 해결하기 위해 HTTP/1.1 스펙에서는 Keep-alive라는 옵션이 추가되어, 연결을 재사용하는것이 가능하게 되었다.Thread per connection vs Thread per request다시 스레드로 돌아가보자.연결 하나당 스레드 하나가 배정된다면, 연결 사이사이에 스레드가 놀지 않을까?사실 현재 웹서버들은 하나의 “연결”에 대해서 스레드를 배정하지 않고,하나의 “요청” 단위로 스레드를 배정한다(Thread per request)요청 단위로 스레드를 배정한다면 생성비용과 해제비용은 어떻게 감당할까?앞에서 잠깐 이야기했듯, 멀티스레드 웹서버들은 스레드풀을 사용하여 관리한다.이게 가능한 이유는 http의 stateless한 특성 때문이라고 이해할 수 있다.생각해보기 - KeepAlive &amp; Thread per request?HTTP/1.1의 KeepAlive는 추가적인 요청에 대해서 연결을 재활용하기 위해 바로 스레드가 반납되지 않고 잠깐 살아있게 된다.이게 Thread per request 모델과 공생이 가능할까?스레드를 재활용하는것은 엄격하게 보면 Thread per connection이 아닐까?"
    /> <meta
      itemprop="datePublished"
      content="2024-01-24T12:00:00+09:00"
    /> 

    <div class="page__inner-wrap">
      
      <header>
        
        <h1 id="page-title" class="page__title" itemprop="headline">
          <p>웹 서버와 포트, 소켓, 그리고 스레드</p>

        </h1>
         
      </header>
      

      <section class="page__content e-content" itemprop="text">
         <h1 id="웹-서버와-포트-소켓-그리고-스레드">웹 서버와 포트, 소켓, 그리고 스레드</h1>

<p><br /></p>

<p>지금까지 웹서버를 설정할 때 아무 생각 없이 포트 설정을 해 왔다.<br />
Nestjs 라면 아래와 같이,</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// main.ts</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nf">bootstrap</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">NestFactory</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nx">AppModule</span><span class="p">);</span>
  <span class="k">await</span> <span class="nx">app</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span> <span class="c1">//  port</span>
<span class="p">}</span>
<span class="nf">bootstrap</span><span class="p">();</span>
</code></pre></div></div>

<p>SpringBoot라면</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//application.properties
server.port=8080
</code></pre></div></div>

<p>이런 식으로 말이다.</p>

<p>이번에 네트워크 관련 스터디를 하면서 포트와 소켓, 그리고 스레드에 대해서 몇가지 의문들이 들었는데, 이번 포스팅에서 하나씩 해결해보려고 한다.</p>

<hr />

<p>먼저 한가지 질문으로 시작해보려고 한다.</p>

<blockquote>
  <p class="prompt-tip">소켓은 하나의 포트와 매칭되는가?</p>
</blockquote>

<p>그렇다.
포트와 IP 주소를 조합하여 하나의 소켓을 구성한다.</p>

<blockquote>
  <p class="prompt-tip">하나의 요청은 하나의 소켓을 갖는다?</p>
</blockquote>

<p>당연하게도 그럴것 같다. 서로 다른 요청들을 구분하고 TCP 연결을 맻으려면 서로 다른 포트(소켓)을 가져야 한다.</p>

<h2 id="웹서버를-구축할-때-설정한-포트는-하나인데">웹서버를 구축할 때 설정한 포트는 하나인데?</h2>

<p>여러개의 요청을 동시에 처리하려면 당연히 여러개의 포트를 사용할것이다.<br />
<strong>우리가 웹서버 애플리케이션에 배정한 포트는 하나인데, 어떻게 여러개의 동시 요청들을 처리하는걸까</strong>?</p>

<h3 id="listening-port">Listening Port</h3>

<p>사실 우리가 서버를 구축할 때 주는 포트번호는 Listening Port라는 특수한 포트이다.<br />
이 포트는 클라이언트들로부터 들어오는 연결 요청을 기다린다.<br />
즉, 우리가 설정한 포트는 어디까지나 중재자 역할을 할 뿐, 직접 요청을 처리하는것이 아니다.</p>

<p><br /></p>

<h3 id="ports-and-sockets">Ports and Sockets</h3>

<p>웹서버는 listening port를 이용해서 요청을 기다린다.<br />
요청이 들어올 경우, 받은 요청에 <strong>ephemeral port(~1024의 예약 포트를 제외한 나머지)</strong> 라고 하는 임시 커넥션 포트를 사용하여 동적으로 소켓을 만들어준다.</p>

<p>생성된 소켓은 톰캣과 같은 멀티스레드 웹서버 환경에서는 보유하고 있는 스레드 풀에서 스레드를 배정받아 요청을 처리하고,<br />
Nodejs 와 같은 싱글스레드 환경이라면 이벤트 루프가 request handler를 호출하여 해당 요청을 처리해준다.</p>

<p><br /></p>

<h3 id="concurrency">Concurrency</h3>

<p>포트개수가 많긴 하지만 결국 6만개밖에 없는게 아닌가? 만약 그 이상의 연결이 들어온다면 웹서버는 요청을 받을 수 없는걸까?</p>

<p>그렇지 않다.
웹서버는 5개의 원소를 가진 tuple을 통해 connection을 구분한다.<br />
Source IP, Source Port, Destination IP, Destination Port, Protocol
이중 하나라도 다르다면 별도의 connection으로 취급하는 것이다.</p>

<p>즉, 두 서버간 총 64K의 Connection이 가능하다는 의미이다.</p>

<p>따라서 포트 하나만 있더라도 서버의 리소스만 충분하다면 Source IP 주소가 모두 다르기 때문에 문제가 없다.</p>

<p><br /></p>

<h3 id="쉬어가기---processes-and-threads">쉬어가기 - Processes and Threads</h3>

<p>옛날 웹서버들은 사실 하나의 연결당 하나의 프로세스를 배정하는 process-per-connection 정책을 사용하였다.<br />
다만 IPC와 프로세스 생성 / 해제의 오버헤드로 인해 프로세스가 아닌 스레드를 배정하는<br />
thread-per-connection 정책을 사용하거나, nodejs와 같은 비동기 방식을 채택하였다.</p>

<p><br /></p>

<h3 id="http11---connection-overhead">HTTP/1.1 - Connection Overhead</h3>

<p>연결 요청마다 매번 새로운 소켓을 생성하고 TCP 요청을 수립하는것은 당연히 비효율적일 것이다.<br />
이를 해결하기 위해 HTTP/1.1 스펙에서는 Keep-alive라는 옵션이 추가되어, 연결을 재사용하는것이 가능하게 되었다.</p>

<p><br /></p>

<h3 id="thread-per-connection-vs-thread-per-request">Thread per connection vs Thread per request</h3>

<p>다시 스레드로 돌아가보자.<br />
연결 하나당 스레드 하나가 배정된다면, 연결 사이사이에 스레드가 놀지 않을까?</p>

<p>사실 현재 웹서버들은 하나의 “연결”에 대해서 스레드를 배정하지 않고,
하나의 “요청” 단위로 스레드를 배정한다(Thread per request)</p>

<p>요청 단위로 스레드를 배정한다면 생성비용과 해제비용은 어떻게 감당할까?<br />
앞에서 잠깐 이야기했듯, 멀티스레드 웹서버들은 스레드풀을 사용하여 관리한다.<br />
이게 가능한 이유는 http의 stateless한 특성 때문이라고 이해할 수 있다.</p>

<p class="question">생각해보기 - KeepAlive &amp; Thread per request?</p>

<p>HTTP/1.1의 KeepAlive는 추가적인 요청에 대해서 연결을 재활용하기 위해 바로 스레드가 반납되지 않고 잠깐 살아있게 된다.</p>

<p>이게 Thread per request 모델과 공생이 가능할까?</p>

<p>스레드를 재활용하는것은 엄격하게 보면 Thread per connection이 아닐까?</p>
 
      </section>

      <footer class="page__meta">
         

 

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 업데이트:</strong> <time class="dt-published" datetime="2024-01-24T12:00:00+09:00">January 24, 2024</time></p>

      </footer>
      
  <nav class="pagination">
    
      <a href="/jpa/persistance/" class="pagination--pager" title="영속성 핥아보기
">이전</a>
    
    
      <a href="/interview/ms_container/" class="pagination--pager" title="CS 면접대비 - 컨테이너
">다음</a>
    
  </nav>

    </div>

    
  </article>

   
  <div class="page__related">
    <h2 class="page__related-title">
      참고
    </h2>
    <div class="grid__wrapper">
       



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/concurrency/" rel="permalink">티케팅 시스템 구현에서의 동시성 문제 : 원인
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> April 02 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">개요
</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tiketeer/architecture/" rel="permalink">스프링 코드 아키텍처
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> March 25 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">작성자 : Claycat

개요

여러분들의 백엔드 프로젝트 아키텍처는 어떤가요?

이번에 지인들과 함께 Java/스프링 기반의 사이드 프로젝트를 진행하고 있습니다.
프로젝트를 진행하던 중 초기 아키텍처 및 디렉토리 구조에 대해서 많은 고민이 있었는데요.
결정 과정에 대해서 소개해...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/isp1/" rel="permalink">인터페이스 분리 원칙에 대해
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">다 알고 있는 사실

  어떤 코드도 자신이 사용하지 않는 메소드에 의존하면 안된다
자신이 사용하는 메서드에만 의존해야 한다


매번 나오는 설명입니다.
보통 이야기를 들어도 잘 이해가 안가기 때문에 보통 예제를 봅니다.

interface Person {
	public void ...</p>
  </article>
</div>
  



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/jpa/persistance2/" rel="permalink">영속성 까보기 (feat. 10분 테코톡)
</a>
      
    </h2>
    <!--
            아키이브 싱글 페이지(ex. 카테고리)에 각 포스트 제목 밑에 Updated 시간 표기
            기존에는 read_time이 표기. read_time -> date 변경
    
    -->
    
    <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> February 27 2024
    </p>
    
    
    <p class="archive__item-excerpt" itemprop="description">JPA와 영속성

JPA 영속성 관련 실험 중 이상한 케이스를 발견했습니다.
우아한형제들 테코톡의 문제상황 1에서도 비슷한 예제가 있습니다.
영상에서는 정확히 이유를 설명하지는 않고 영속성 설명으로 넘어가버려서
정확한 이유를 정리해보려고 합니다.

@Getter
@Entity
@A...</p>
  </article>
</div>
 
    </div>
  </div>
   
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력하세요..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>팔로우:</strong></li>
    

    
      
        
          <li><a href="https://github.com/claycat" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Claycat. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', 'claycat');
    script.setAttribute('data-repo-id', 'R_kgDOLLYTXw');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOLLYTX84Ccyz5');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('crossorigin', 'anonymous');

    commentContainer.appendChild(script);
  })();
</script>
  





  </body>
</html>
